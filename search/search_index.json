{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction AnchorPy is the Python client for Anchor . It allows you to interact with Anchor programs using Python instead of Typescript/Javascript. Installation pip install anchorpy Note These docs will assume you've read the Anchor documentation first.","title":"Introduction"},{"location":"#introduction","text":"AnchorPy is the Python client for Anchor . It allows you to interact with Anchor programs using Python instead of Typescript/Javascript.","title":"Introduction"},{"location":"#installation","text":"pip install anchorpy Note These docs will assume you've read the Anchor documentation first.","title":"Installation"},{"location":"api_reference/","text":"API Reference Program Program provides the IDL deserialized client representation of an Anchor program. This API is the one stop shop for all things related to communicating with on-chain programs. Among other things, one can send transactions, fetch deserialized accounts, decode instruction data, subscribe to account changes, and listen to events. In addition to field accessors and methods, the object provides a set of dynamically generated properties, also known as namespaces, that map one-to-one to program methods and accounts. __init__ ( self , idl , program_id , provider = None ) special Initialize the Program object. Parameters: Name Type Description Default idl Idl The parsed IDL object. required program_id PublicKey The program ID. required provider Optional[Provider] The Provider object for the Program. Defaults to Provider.local(). None Source code in anchorpy/program/core.py def __init__ ( self , idl : Idl , program_id : PublicKey , provider : Optional [ Provider ] = None ): \"\"\"Initialize the Program object. Args: idl: The parsed IDL object. program_id: The program ID. provider: The Provider object for the Program. Defaults to Provider.local(). \"\"\" self . idl = idl self . program_id = program_id self . provider = provider if provider is not None else Provider . local () self . coder = Coder ( idl ) ( # noqa: WPS236 rpc , instruction , transaction , account , simulate , types , ) = _build_namespace ( idl , self . coder , program_id , self . provider , ) self . rpc = rpc self . instruction = instruction self . transaction = transaction self . account = account self . simulate = simulate self . type = types at ( address , provider = None ) async classmethod Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's anchor idl init command. Parameters: Name Type Description Default address AddressType The program ID. required provider Optional[Provider] The network and wallet context. None Returns: Type Description Program The Program instantiated using the fetched IDL. Source code in anchorpy/program/core.py @classmethod async def at ( cls , address : AddressType , provider : Optional [ Provider ] = None , ) -> Program : \"\"\"Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's `anchor idl init` command. Args: address: The program ID. provider: The network and wallet context. Returns: The Program instantiated using the fetched IDL. \"\"\" provider_to_use = Provider . local () if provider is None else provider program_id = translate_address ( address ) idl = await cls . fetch_idl ( program_id , provider_to_use ) return cls ( idl , program_id , provider ) close ( self ) async Use this when you are done with the client. Source code in anchorpy/program/core.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . provider . close () fetch_idl ( address , provider ) async classmethod Fetch and parse an idl from the blockchain. Parameters: Name Type Description Default address AddressType The program ID. required provider Provider The network and wallet context. required Returns: Type Description Idl The fetched IDL. Source code in anchorpy/program/core.py @classmethod async def fetch_idl ( cls , address : AddressType , provider : Provider , ) -> Idl : \"\"\"Fetch and parse an idl from the blockchain. Args: address: The program ID. provider: The network and wallet context. Returns: Idl: The fetched IDL. \"\"\" raw = await cls . fetch_raw_idl ( address , provider ) return Idl . from_json ( raw ) fetch_raw_idl ( address , provider ) async classmethod Fetch an idl from the blockchain as a raw JSON dictionary. Parameters: Name Type Description Default address AddressType The program ID. required provider Provider The network and wallet context. required Exceptions: Type Description IdlNotFoundError If the requested IDL account does not exist. Returns: Type Description Idl The raw IDL. Source code in anchorpy/program/core.py @classmethod async def fetch_raw_idl ( cls , address : AddressType , provider : Provider , ) -> dict [ str , Any ]: \"\"\"Fetch an idl from the blockchain as a raw JSON dictionary. Args: address: The program ID. provider: The network and wallet context. Raises: IdlNotFoundError: If the requested IDL account does not exist. Returns: Idl: The raw IDL. \"\"\" program_id = translate_address ( address ) actual_provider = provider if provider is not None else Provider . local () idl_addr = _idl_address ( program_id ) account_info = await actual_provider . connection . get_account_info ( idl_addr ) account_info_val = account_info [ \"result\" ][ \"value\" ] if account_info_val is None : raise IdlNotFoundError ( f \"IDL not found for program: { address } \" ) idl_account = _decode_idl_account ( b64decode ( account_info_val [ \"data\" ][ 0 ])[ ACCOUNT_DISCRIMINATOR_SIZE :] ) inflated_idl = _pako_inflate ( bytes ( idl_account [ \"data\" ])) . decode () return json . loads ( inflated_idl ) Provider The network and wallet context used to send transactions paid for and signed by the provider. __init__ ( self , connection , wallet , opts = TxOpts ( skip_confirmation = False , skip_preflight = False , preflight_commitment = 'processed' )) special Initialize the Provider. Parameters: Name Type Description Default connection AsyncClient The cluster connection where the program is deployed. required wallet Wallet The wallet used to pay for and sign all transactions. required opts types.TxOpts Transaction confirmation options to use by default. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed') Source code in anchorpy/provider.py def __init__ ( self , connection : AsyncClient , wallet : Wallet , opts : types . TxOpts = DEFAULT_OPTIONS , ) -> None : \"\"\"Initialize the Provider. Args: connection: The cluster connection where the program is deployed. wallet: The wallet used to pay for and sign all transactions. opts: Transaction confirmation options to use by default. \"\"\" self . connection = connection self . wallet = wallet self . opts = opts close ( self ) async Use this when you are done with the connection. Source code in anchorpy/provider.py async def close ( self ) -> None : \"\"\"Use this when you are done with the connection.\"\"\" await self . connection . close () env () classmethod Create a Provider using the ANCHOR_PROVIDER_URL environment variable. Source code in anchorpy/provider.py @classmethod def env ( cls ) -> Provider : \"\"\"Create a `Provider` using the `ANCHOR_PROVIDER_URL` environment variable.\"\"\" url = environ [ \"ANCHOR_PROVIDER_URL\" ] options = DEFAULT_OPTIONS connection = AsyncClient ( url , options . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , options ) local ( url = None , opts = TxOpts ( skip_confirmation = False , skip_preflight = False , preflight_commitment = 'processed' )) classmethod Create a Provider with a wallet read from the local filesystem. Parameters: Name Type Description Default url Optional[str] The network cluster url. None opts types.TxOpts The default transaction confirmation options. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed') Source code in anchorpy/provider.py @classmethod def local ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` with a wallet read from the local filesystem. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , opts ) send ( self , tx , signers = None , opts = None ) async Send the given transaction, paid for and signed by the provider's wallet. Parameters: Name Type Description Default tx Transaction The transaction to send. required signers Optional[list[Keypair]] The set of signers in addition to the provider wallet that will sign the transaction. None opts types.TxOpts Transaction confirmation options. None Returns: Type Description TransactionSignature The transaction signature from the RPC server. Source code in anchorpy/provider.py async def send ( self , tx : Transaction , signers : Optional [ list [ Keypair ]] = None , opts : types . TxOpts = None , ) -> TransactionSignature : \"\"\"Send the given transaction, paid for and signed by the provider's wallet. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction signature from the RPC server. \"\"\" if signers is None : signers = [] if opts is None : opts = self . opts all_signers = list ( unique_everseen ([ self . wallet . payer ] + signers )) resp = await self . connection . send_transaction ( tx , * all_signers , opts = opts ) return resp [ \"result\" ] send_all ( self , reqs , opts = None ) async Similar to send , but for an array of transactions and signers. Parameters: Name Type Description Default reqs list[Union[Transaction, SendTxRequest]] a list of Transaction or SendTxRequest objects. Use SendTxRequest to specify additional signers other than the wallet. required opts Optional[types.TxOpts] Transaction confirmation options. None Returns: Type Description list[TransactionSignature] The transaction signatures from the RPC server. Source code in anchorpy/provider.py async def send_all ( self , reqs : list [ Union [ Transaction , SendTxRequest ]], opts : Optional [ types . TxOpts ] = None , ) -> list [ TransactionSignature ]: \"\"\"Similar to `send`, but for an array of transactions and signers. Args: reqs: a list of Transaction or SendTxRequest objects. Use SendTxRequest to specify additional signers other than the wallet. opts: Transaction confirmation options. Returns: The transaction signatures from the RPC server. \"\"\" if opts is None : opts = self . opts txs = [] for req in reqs : signers = [] if isinstance ( req , Transaction ) else req . signers tx = req if isinstance ( req , Transaction ) else req . tx for signer in signers : tx . sign_partial ( signer ) txs . append ( tx ) signed_txs = self . wallet . sign_all_transactions ( txs ) sigs = [] for signed in signed_txs : resp = await self . connection . send_raw_transaction ( signed . serialize (), opts = opts ) sigs . append ( resp [ \"result\" ]) return sigs simulate ( self , tx , signers = None , opts = None ) async Simulate the given transaction, returning emitted logs from execution. Parameters: Name Type Description Default tx Transaction The transaction to send. required signers Optional[list[Keypair]] The set of signers in addition to the provider wallet that will sign the transaction. None opts types.TxOpts Transaction confirmation options. None Returns: Type Description types.RPCResponse The transaction signature from the RPC server. Source code in anchorpy/provider.py async def simulate ( self , tx : Transaction , signers : Optional [ list [ Keypair ]] = None , opts : types . TxOpts = None , ) -> types . RPCResponse : \"\"\"Simulate the given transaction, returning emitted logs from execution. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction signature from the RPC server. \"\"\" if signers is None : signers = [] if opts is None : opts = self . opts recent_blockhash_resp = await self . connection . get_recent_blockhash ( Finalized , ) tx . recent_blockhash = recent_blockhash_resp [ \"result\" ][ \"value\" ][ \"blockhash\" ] all_signers = list ( unique_everseen ([ self . wallet . payer ] + signers )) tx . sign ( * all_signers ) return await self . connection . simulate_transaction ( tx , sig_verify = True , commitment = opts . preflight_commitment ) Context dataclass Context provides all non-argument inputs for generating Anchor transactions. Attributes: Name Type Description accounts Dict[str, Any] The accounts used in the instruction context. remaining_accounts List[solana.transaction.AccountMeta] All accounts to pass into an instruction after the main signers List[solana.keypair.Keypair] Accounts that must sign a given transaction. pre_instructions List[solana.transaction.TransactionInstruction] Instructions to run before a given method. Often this is used, for example to create accounts prior to executing a method. post_instructions List[solana.transaction.TransactionInstruction] Instructions to run after a given method. Often this is used, for example to close accounts prior to executing a method. options Optional[solana.rpc.types.TxOpts] Commitment parameters to use for a transaction. create_workspace ( path = None , url = None ) Get a workspace from the provided path to the project root. Parameters: Name Type Description Default path Union[pathlib.Path, str] The path to the project root. Defaults to the current working directory if omitted. None url Optional[str] The URL of the JSON RPC. Defaults to http://localhost:8899. None Returns: Type Description Dict[str, anchorpy.program.core.Program] Mapping of program name to Program object. Source code in anchorpy/workspace.py def create_workspace ( path : Optional [ Union [ Path , str ]] = None , url : Optional [ str ] = None ) -> WorkspaceType : \"\"\"Get a workspace from the provided path to the project root. Args: path: The path to the project root. Defaults to the current working directory if omitted. url: The URL of the JSON RPC. Defaults to http://localhost:8899. Returns: Mapping of program name to Program object. \"\"\" result = {} project_root = Path . cwd () if path is None else Path ( path ) idl_folder = project_root / \"target/idl\" for file in idl_folder . iterdir (): with file . open () as f : idl_dict = json . load ( f ) idl = Idl . from_json ( idl_dict ) metadata = cast ( _Metadata , idl . metadata ) program = Program ( idl , PublicKey ( metadata . address ), Provider . local ( url )) result [ idl . name ] = program return result close_workspace ( workspace ) async Close the HTTP clients of all the programs in the workspace. Parameters: Name Type Description Default workspace Dict[str, anchorpy.program.core.Program] The workspace to close. required Source code in anchorpy/workspace.py async def close_workspace ( workspace : WorkspaceType ) -> None : \"\"\"Close the HTTP clients of all the programs in the workspace. Args: workspace: The workspace to close. \"\"\" for program in workspace . values (): # could do this in a faster way but there's probably no point. await program . close () Idl dataclass A parsed IDL object. from_json ( idl ) classmethod Generate a parsed IDL from a JSON dict. Parameters: Name Type Description Default idl Dict[str, Any] The raw IDL dict. required Returns: Type Description Idl The parsed Idl object. Source code in anchorpy/idl.py @classmethod def from_json ( cls , idl : Dict [ str , Any ]) -> \"Idl\" : \"\"\"Generate a parsed IDL from a JSON dict. Args: idl: The raw IDL dict. Returns: The parsed Idl object. \"\"\" return deserialize ( cls , idl ) workspace_fixture ( path , scope = 'module' , timeout_seconds = 60 , build_cmd = None ) Create a fixture that sets up and tears down a localnet instance and returns a workspace dict. Equivalent to combining localnet_fixture , create_workspace and close_workspace . Parameters: Name Type Description Default path Union[pathlib.Path, str] Path to root of the Anchor project. required scope str Pytest fixture scope. 'module' timeout_seconds int Time to wait for Anchor localnet to start. 60 build_cmd Optional[str] Command to run before anchor localnet . Defaults to anchor build . None Returns: Type Description Callable A workspace fixture for use with pytest. Source code in anchorpy/pytest_plugin.py def workspace_fixture ( path : Union [ Path , str ], scope : str = \"module\" , timeout_seconds : int = 60 , build_cmd : Optional [ str ] = None , ) -> Callable : \"\"\"Create a fixture that sets up and tears down a localnet instance and returns a workspace dict. Equivalent to combining `localnet_fixture`, `create_workspace` and `close_workspace`. Args: path: Path to root of the Anchor project. scope: Pytest fixture scope. timeout_seconds: Time to wait for Anchor localnet to start. build_cmd: Command to run before `anchor localnet`. Defaults to `anchor build`. Returns: A workspace fixture for use with pytest. \"\"\" # noqa: E501,D202 @fixture ( scope = scope ) async def _workspace_fixture ( _fixed_xprocess , ) -> AsyncGenerator [ dict [ str , Program ], None ]: class Starter ( ProcessStarter ): # startup pattern pattern = \"JSON RPC URL\" terminate_on_interrupt = True # command to start process args = [ \"anchor\" , \"localnet\" , \"--skip-build\" ] timeout = timeout_seconds popen_kwargs = { \"cwd\" : path , \"start_new_session\" : True , } max_read_lines = 1_000 # command to start process actual_build_cmd = \"anchor build\" if build_cmd is None else build_cmd subprocess . run ( actual_build_cmd , cwd = path , check = True , shell = True ) # noqa: S603 # ensure process is running _ = _fixed_xprocess . ensure ( \"localnet\" , Starter ) ws = create_workspace ( path ) yield ws await close_workspace ( ws ) # clean up whole process tree afterwards _fixed_xprocess . getinfo ( \"localnet\" ) . terminate () return _workspace_fixture localnet_fixture ( path , scope = 'module' , timeout_seconds = 60 , build_cmd = None ) Create a fixture that sets up and tears down a localnet instance with workspace programs deployed. Parameters: Name Type Description Default path Path Path to root of the Anchor project. required scope str Pytest fixture scope. 'module' timeout_seconds int Time to wait for Anchor localnet to start. 60 build_cmd Optional[str] Command to run before anchor localnet . Defaults to anchor build . None Returns: Type Description Callable A localnet fixture for use with pytest. Source code in anchorpy/pytest_plugin.py def localnet_fixture ( path : Path , scope : str = \"module\" , timeout_seconds : int = 60 , build_cmd : Optional [ str ] = None , ) -> Callable : \"\"\"Create a fixture that sets up and tears down a localnet instance with workspace programs deployed. Args: path: Path to root of the Anchor project. scope: Pytest fixture scope. timeout_seconds: Time to wait for Anchor localnet to start. build_cmd: Command to run before `anchor localnet`. Defaults to `anchor build`. Returns: A localnet fixture for use with pytest. \"\"\" # noqa: E501,D202 @fixture ( scope = scope ) def _localnet_fixture ( _fixed_xprocess ): class Starter ( ProcessStarter ): # startup pattern pattern = \"JSON RPC URL\" terminate_on_interrupt = True # command to start process args = [ \"anchor\" , \"localnet\" , \"--skip-build\" ] timeout = timeout_seconds popen_kwargs = { \"cwd\" : path , \"start_new_session\" : True , } max_read_lines = 1_000 # command to start process actual_build_cmd = \"anchor build\" if build_cmd is None else build_cmd subprocess . run ( actual_build_cmd , cwd = path , check = True , shell = True ) # noqa: S603 # ensure process is running and return its logfile logfile = _fixed_xprocess . ensure ( \"localnet\" , Starter ) yield logfile # clean up whole process tree afterwards _fixed_xprocess . getinfo ( \"localnet\" ) . terminate () return _localnet_fixture Wallet Python wallet object. public_key : PublicKey property readonly Get the public key of the wallet. __init__ ( self , payer ) special Initialize the wallet. Parameters: Name Type Description Default payer Keypair the Keypair used to sign transactions. required Source code in anchorpy/provider.py def __init__ ( self , payer : Keypair ): \"\"\"Initialize the wallet. Args: payer: the Keypair used to sign transactions. \"\"\" self . payer = payer local () classmethod Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. Source code in anchorpy/provider.py @classmethod def local ( cls ) -> Wallet : \"\"\"Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. \"\"\" path = Path ( getenv ( \"ANCHOR_WALLET\" , Path . home () / \".config/solana/id.json\" )) with path . open () as f : keypair = json . load ( f ) return cls ( Keypair . from_secret_key ( bytes ( keypair ))) sign_all_transactions ( self , txs ) Sign a list of transactions using the wallet's keypair. Parameters: Name Type Description Default txs list[Transaction] The transactions to sign. required Returns: Type Description list[Transaction] The signed transactions. Source code in anchorpy/provider.py def sign_all_transactions ( self , txs : list [ Transaction ]) -> list [ Transaction ]: \"\"\"Sign a list of transactions using the wallet's keypair. Args: txs: The transactions to sign. Returns: The signed transactions. \"\"\" for tx in txs : tx . sign_partial ( self . payer ) return txs sign_transaction ( self , tx ) Sign a transaction using the wallet's keypair. Parameters: Name Type Description Default tx Transaction The transaction to sign. required Returns: Type Description Transaction The signed transaction. Source code in anchorpy/provider.py def sign_transaction ( self , tx : Transaction ) -> Transaction : \"\"\"Sign a transaction using the wallet's keypair. Args: tx: The transaction to sign. Returns: The signed transaction. \"\"\" tx . sign ( self . payer ) return tx SendTxRequest ( tuple ) Use this to provide custom signers to Provider.send_all . Attributes: Name Type Description tx Transaction The Transaction to send. signers List[solana.keypair.Keypair] Custom signers for the transaction. Coder Coder provides a facade for encoding and decoding all IDL related objects. __init__ ( self , idl ) special Initialize the coder. Parameters: Name Type Description Default idl Idl a parsed Idl instance. required Source code in anchorpy/coder/coder.py def __init__ ( self , idl : Idl ): \"\"\"Initialize the coder. Args: idl: a parsed Idl instance. \"\"\" self . instruction : InstructionCoder = InstructionCoder ( idl ) self . accounts : AccountsCoder = AccountsCoder ( idl ) self . events : EventCoder = EventCoder ( idl ) InstructionCoder ( Adapter ) Encodes and decodes program instructions. __init__ ( self , idl ) special Init. Parameters: Name Type Description Default idl Idl The parsed IDL object. required Source code in anchorpy/coder/instruction.py def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . ix_layout = _parse_ix_layout ( idl ) sighasher = _Sighash () sighash_layouts : Dict [ bytes , Construct ] = {} sighashes : Dict [ str , bytes ] = {} sighash_to_name : Dict [ bytes , str ] = {} for ix in idl . instructions : sh = sighasher . build ( ix . name ) sighashes [ ix . name ] = sh sighash_layouts [ sh ] = self . ix_layout [ ix . name ] sighash_to_name [ sh ] = ix . name self . sighash_layouts = sighash_layouts self . sighashes = sighashes self . sighash_to_name = sighash_to_name subcon = Sequence ( \"sighash\" / Bytes ( 8 ), Switch ( lambda this : this . sighash , sighash_layouts ), ) super () . __init__ ( subcon ) # type: ignore encode ( self , ix_name , ix ) Encode a program instruction. Parameters: Name Type Description Default ix_name str The name of the instruction required ix Dict[str, Any] The data to encode. required Returns: Type Description bytes The encoded instruction. Source code in anchorpy/coder/instruction.py def encode ( self , ix_name : str , ix : Dict [ str , Any ]) -> bytes : \"\"\"Encode a program instruction. Args: ix_name: The name of the instruction ix: The data to encode. Returns: The encoded instruction. \"\"\" return self . build ( Instruction ( name = ix_name , data = ix )) EventCoder ( Adapter ) Encodes and decodes Anchor events. __init__ ( self , idl ) special Initialize the EventCoder. Parameters: Name Type Description Default idl Idl The parsed Idl object. required Source code in anchorpy/coder/event.py def __init__ ( self , idl : Idl ): \"\"\"Initialize the EventCoder. Args: idl: The parsed Idl object. \"\"\" self . idl = idl idl_events = idl . events layouts : Dict [ str , Construct ] if idl_events : layouts = { event . name : _event_layout ( event , idl ) for event in idl_events } else : layouts = {} self . layouts = layouts self . discriminators : Dict [ bytes , str ] = { _event_discriminator ( event . name ): event . name for event in idl_events } self . discriminator_to_layout = { disc : self . layouts [ event_name ] for disc , event_name in self . discriminators . items () } subcon = Sequence ( \"discriminator\" / Bytes ( 8 ), # not base64-encoded here Switch ( lambda this : this . discriminator , self . discriminator_to_layout ), ) super () . __init__ ( subcon ) # type: ignore AccountsCoder ( Adapter ) Encodes and decodes account data. __init__ ( self , idl ) special Init. Parameters: Name Type Description Default idl Idl The parsed IDL object. required Source code in anchorpy/coder/accounts.py def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . _accounts_layout = { acc . name : _typedef_layout ( acc , idl . types , acc . name ) for acc in idl . accounts } self . acc_name_to_discriminator = { acc . name : _account_discriminator ( acc . name ) for acc in idl . accounts } self . discriminator_to_acc_name = { disc : acc_name for acc_name , disc in self . acc_name_to_discriminator . items () } discriminator_to_typedef_layout = { disc : self . _accounts_layout [ acc_name ] for acc_name , disc in self . acc_name_to_discriminator . items () } subcon = Sequence ( \"discriminator\" / Bytes ( ACCOUNT_DISCRIMINATOR_SIZE ), Switch ( lambda this : this . discriminator , discriminator_to_typedef_layout ), ) super () . __init__ ( subcon ) # type: ignore decode ( self , obj ) Decode account data. Parameters: Name Type Description Default obj bytes Data to decode. required Returns: Type Description Container Decoded data. Source code in anchorpy/coder/accounts.py def decode ( self , obj : bytes ) -> Container [ Any ]: \"\"\"Decode account data. Args: obj: Data to decode. Returns: Decoded data. \"\"\" return self . parse ( obj ) . data Instruction dataclass Container for a named instruction. Attributes: Name Type Description data Union[Dict[str, Any], construct.lib.containers.Container[Any]] The actual instruction data. name str The name of the instruction. IdlProgramAccount ( dict ) The on-chain account of the IDL. Event ( tuple ) A parsed event object. translate_address ( address ) Convert str | PublicKey into PublicKey . Parameters: Name Type Description Default address Union[solana.publickey.PublicKey, str] Public key as string or PublicKey . required Returns: Type Description PublicKey Public key as PublicKey . Source code in anchorpy/program/common.py def translate_address ( address : AddressType ) -> PublicKey : \"\"\"Convert `str | PublicKey` into `PublicKey`. Args: address: Public key as string or `PublicKey`. Returns: Public key as `PublicKey`. \"\"\" if isinstance ( address , str ): return PublicKey ( address ) return address validate_accounts ( ix_accounts , accounts ) Check that accounts passed in ctx match the IDL. Parameters: Name Type Description Default ix_accounts list Accounts from the IDL. required accounts Dict[str, Any] Accounts from the ctx arg. required Exceptions: Type Description ValueError If ctx accounts don't match the IDL. Source code in anchorpy/program/common.py def validate_accounts ( ix_accounts : list [ _IdlAccountItem ], accounts : Accounts ): \"\"\"Check that accounts passed in `ctx` match the IDL. Args: ix_accounts: Accounts from the IDL. accounts: Accounts from the `ctx` arg. Raises: ValueError: If `ctx` accounts don't match the IDL. \"\"\" for acc in ix_accounts : if isinstance ( acc , get_args ( _IdlAccounts )): idl_accounts = cast ( _IdlAccounts , acc ) validate_accounts ( idl_accounts . accounts , accounts [ acc . name ]) elif acc . name not in accounts : raise ValueError ( f \"Invalid arguments: { acc . name } not provided\" ) AccountClient Provides methods for fetching and creating accounts. coder : Coder property readonly Return the coder. program_id : PublicKey property readonly Return the program ID owning all accounts. provider : Provider property readonly Return the client's wallet and network provider. size : int property readonly Return the number of bytes in this account. __init__ ( self , idl , idl_account , coder , program_id , provider ) special Init. Parameters: Name Type Description Default idl Idl the parsed IDL object. required idl_account _IdlTypeDef the account definition from the IDL. required coder Coder The program's Coder object. required program_id PublicKey the program ID. required provider Provider The Provider object for the Program. required Source code in anchorpy/program/namespace/account.py def __init__ ( self , idl : Idl , idl_account : _IdlTypeDef , coder : Coder , program_id : PublicKey , provider : Provider , ): \"\"\"Init. Args: idl: the parsed IDL object. idl_account: the account definition from the IDL. coder: The program's Coder object. program_id: the program ID. provider: The Provider object for the Program. \"\"\" self . _idl_account = idl_account self . _program_id = program_id self . _provider = provider self . _coder = coder self . _size = ACCOUNT_DISCRIMINATOR_SIZE + _account_size ( idl , idl_account ) all ( self , buffer = None , memcmp_opts = None , data_size = None ) async Return all instances of this account type for the program. Parameters: Name Type Description Default buffer Optional[bytes] bytes filter to append to the discriminator. None memcmp_opts Optional[list[solana.rpc.types.MemcmpOpts]] Options to compare a provided series of bytes with program account data at a particular offset. None data_size Optional[int] Option to compare the program account data length with the provided data size. None Source code in anchorpy/program/namespace/account.py async def all ( self , buffer : Optional [ bytes ] = None , memcmp_opts : Optional [ list [ MemcmpOpts ]] = None , data_size : Optional [ int ] = None , ) -> list [ ProgramAccount ]: \"\"\"Return all instances of this account type for the program. Args: buffer: bytes filter to append to the discriminator. memcmp_opts: Options to compare a provided series of bytes with program account data at a particular offset. data_size: Option to compare the program account data length with the provided data size. \"\"\" all_accounts = [] discriminator = _account_discriminator ( self . _idl_account . name ) to_encode = discriminator if buffer is None else discriminator + buffer bytes_arg = b58encode ( to_encode ) . decode ( \"ascii\" ) base_memcmp_opt = MemcmpOpts ( offset = 0 , bytes = bytes_arg , ) extra_memcmpm_opts = [] if memcmp_opts is None else memcmp_opts full_memcmp_opts = [ base_memcmp_opt ] + extra_memcmpm_opts resp = await self . _provider . connection . get_program_accounts ( self . _program_id , encoding = \"base64\" , commitment = self . provider . connection . _commitment , # noqa: WPS437 data_size = data_size , memcmp_opts = full_memcmp_opts , ) for r in resp [ \"result\" ]: account_data = r [ \"account\" ][ \"data\" ][ 0 ] account_data = base64 . b64decode ( account_data ) all_accounts . append ( ProgramAccount ( public_key = PublicKey ( r [ \"pubkey\" ]), account = self . _coder . accounts . decode ( account_data ), ), ) return all_accounts create_instruction ( self , signer , size_override = 0 ) async Return an instruction for creating this account. Parameters: Name Type Description Default signer Keypair [description] required size_override int Optional override for the account size. Defaults to 0. 0 Returns: Type Description TransactionInstruction The instruction to create the account. Source code in anchorpy/program/namespace/account.py async def create_instruction ( self , signer : Keypair , size_override : int = 0 , ) -> TransactionInstruction : \"\"\"Return an instruction for creating this account. Args: signer: [description] size_override: Optional override for the account size. Defaults to 0. Returns: The instruction to create the account. \"\"\" space = size_override if size_override else self . _size mbre_resp = ( await self . _provider . connection . get_minimum_balance_for_rent_exemption ( space ) ) return create_account ( CreateAccountParams ( from_pubkey = self . _provider . wallet . public_key , new_account_pubkey = signer . public_key , space = space , lamports = mbre_resp [ \"result\" ], program_id = self . _program_id , ) ) fetch ( self , address ) async Return a deserialized account. Parameters: Name Type Description Default address PublicKey The address of the account to fetch. required Exceptions: Type Description AccountDoesNotExistError If the account doesn't exist. AccountInvalidDiscriminator If the discriminator doesn't match the IDL. Source code in anchorpy/program/namespace/account.py async def fetch ( self , address : PublicKey ) -> Container [ Any ]: \"\"\"Return a deserialized account. Args: address: The address of the account to fetch. Raises: AccountDoesNotExistError: If the account doesn't exist. AccountInvalidDiscriminator: If the discriminator doesn't match the IDL. \"\"\" account_info = await self . _provider . connection . get_account_info ( address , encoding = \"base64\" , ) if not account_info [ \"result\" ][ \"value\" ]: raise AccountDoesNotExistError ( f \"Account { address } does not exist\" ) data = base64 . b64decode ( account_info [ \"result\" ][ \"value\" ][ \"data\" ][ 0 ]) discriminator = _account_discriminator ( self . _idl_account . name ) if discriminator != data [: ACCOUNT_DISCRIMINATOR_SIZE ]: msg = f \"Account { address } has an invalid discriminator\" raise AccountInvalidDiscriminator ( msg ) return self . _coder . accounts . decode ( data ) fetch_multiple ( self , addresses , batch_size = 300 ) async Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Parameters: Name Type Description Default addresses List[solana.publickey.PublicKey] The addresses of the accounts to fetch. required batch_size int The number of getMultipleAccounts objects to send in each HTTP request. 300 Source code in anchorpy/program/namespace/account.py async def fetch_multiple ( self , addresses : List [ PublicKey ], batch_size : int = 300 ) -> list [ Optional [ Container [ Any ]]]: \"\"\"Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Args: addresses: The addresses of the accounts to fetch. batch_size: The number of `getMultipleAccounts` objects to send in each HTTP request. \"\"\" accounts = await get_multiple_accounts ( self . _provider . connection , addresses , batch_size = batch_size , ) discriminator = _account_discriminator ( self . _idl_account . name ) result : list [ Optional [ Container [ Any ]]] = [] for account in accounts : if account is None : result . append ( None ) elif discriminator == account . account . data [: 8 ]: result . append ( self . _coder . accounts . decode ( account . account . data )) else : result . append ( None ) return result ProgramAccount dataclass Deserialized account owned by a program. EventParser dataclass Parser to handle on_logs callbacks. handle_log ( self , execution , log ) Main log handler. Parameters: Name Type Description Default execution _ExecutionContext The execution stack. required log str log string from the RPC node. required Returns: Type Description tuple A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). Source code in anchorpy/program/event.py def handle_log ( self , execution : _ExecutionContext , log : str , ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Main log handler. Args: execution: The execution stack. log: log string from the RPC node. Returns: A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). \"\"\" # noqa: D401 # Executing program is this program. if execution . stack and execution . program () == str ( self . program_id ): return self . handle_program_log ( log ) # Executing program is not this program. return ( None , * self . handle_system_log ( log )) handle_program_log ( self , log ) Handle logs from this program. Parameters: Name Type Description Default log str log string from the RPC node. required Source code in anchorpy/program/event.py def handle_program_log ( self , log : str ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Handle logs from *this* program. Args: log: log string from the RPC node. \"\"\" # This is a `msg!` log. if log . startswith ( \"Program log:\" ): log_str = log [ LOG_START_INDEX :] try : decoded = b64decode ( log_str ) except binascii . Error : return None , None , False event = self . coder . events . parse ( decoded ) return event , None , False return ( None , * self . handle_system_log ( log )) handle_system_log ( self , log ) Handle logs when the current program being executing is not this. Parameters: Name Type Description Default log str log string from the RPC node. required Source code in anchorpy/program/event.py def handle_system_log ( self , log : str ) -> tuple [ Optional [ str ], bool ]: \"\"\"Handle logs when the current program being executing is *not* this. Args: log: log string from the RPC node. \"\"\" log_start = log . split ( \":\" )[ 0 ] splitted = log_start . split ( \" \" ) invoke_msg = f \"Program { str ( self . program_id ) } invoke\" # noqa: WPS237 if len ( splitted ) == 3 and splitted [ 0 ] == \"Program\" and splitted [ 2 ] == \"success\" : return None , True if log_start . startswith ( invoke_msg ): return str ( self . program_id ), False if \"invoke\" in log_start : return \"cpi\" , False return None , False parse_logs ( self , logs , callback ) Parse a list of logs using a provided callback. Parameters: Name Type Description Default logs List[str] The logs to parse. required callback Callable[[anchorpy.program.common.Event], NoneType] The function to handle the parsed log. required Source code in anchorpy/program/event.py def parse_logs ( self , logs : List [ str ], callback : Callable [[ Event ], None ]) -> None : \"\"\"Parse a list of logs using a provided callback. Args: logs: The logs to parse. callback: The function to handle the parsed log. \"\"\" log_scanner = _LogScanner ( logs ) execution = _ExecutionContext ( cast ( str , log_scanner . to_next ())) log = log_scanner . to_next () while log is not None : event , new_program , did_pop = self . handle_log ( execution , log ) if event is not None : callback ( event ) if new_program is not None : execution . push ( new_program ) if did_pop : execution . pop () log = log_scanner . to_next () SimulateResponse ( tuple ) The result of a simulate function call. error This module handles AnchorPy errors. AccountDoesNotExistError ( Exception ) Raise if account doesn't exist. AccountInvalidDiscriminator ( Exception ) Raise if account discriminator doesn't match the IDL. ArgsError ( Exception ) Raise when the incorrect number of args is passed to the RPC function. IdlNotFoundError ( Exception ) Raise when requested IDL account does not exist. ProgramError ( Exception ) An error from a user defined program. __init__ ( self , code , msg ) special Init. Parameters: Name Type Description Default code int The error code. required msg str The error message. required Source code in anchorpy/error.py def __init__ ( self , code : int , msg : str ) -> None : \"\"\"Init. Args: code: The error code. msg: The error message. \"\"\" self . code = code self . msg = msg super () . __init__ ( f \" { code } : { msg } \" ) parse ( err_info , idl_errors ) classmethod Convert an RPC error into a ProgramError, if possible. Parameters: Name Type Description Default err_info Union[RPCError, _ExtendedRPCError] The plain RPC error. required idl_errors dict[int, str] Errors from the IDL file. required Returns: Type Description Optional[ProgramError] A ProgramError or None. Source code in anchorpy/error.py @classmethod def parse ( cls , err_info : Union [ RPCError , _ExtendedRPCError ], idl_errors : dict [ int , str ], ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The plain RPC error. idl_errors: Errors from the IDL file. Returns: A ProgramError or None. \"\"\" try : # noqa: WPS229 err_data = cast ( _ExtendedRPCError , err_info )[ \"data\" ] custom_err_code = err_data [ \"err\" ][ \"InstructionError\" ][ 1 ][ \"Custom\" ] except ( KeyError , TypeError ): return None # parse user error msg = idl_errors . get ( custom_err_code ) if msg is not None : return ProgramError ( custom_err_code , msg ) # parse framework internal error msg = LangErrorMessage . get ( custom_err_code ) if msg is not None : return ProgramError ( custom_err_code , msg ) # Unable to parse the error. Just return the untranslated error. return None utils special Various utility functions. rpc This module contains the invoke function. AccountInfo ( tuple ) Information describing an account. Attributes: Name Type Description executable bool True if this account's data contains a loaded program. owner PublicKey Identifier of the program that owns the account. lamports int Number of lamports assigned to the account. data bytes Optional data assigned to the account. rent_epoch Optional[int] Optional rent epoch info for for account. get_multiple_accounts ( connection , pubkeys , batch_size = 3 ) async Fetch multiple account infos through batched getMultipleAccount RPC requests. Parameters: Name Type Description Default connection AsyncClient The solana-py client object. required pubkeys list Pubkeys to fetch. required batch_size int The number of getMultipleAccount objects to include in each HTTP request. 3 Returns: Type Description list Account infos and pubkeys. Source code in anchorpy/utils/rpc.py async def get_multiple_accounts ( connection : AsyncClient , pubkeys : list [ PublicKey ], batch_size : int = 3 ) -> list [ Optional [ _MultipleAccountsItem ]]: \"\"\"Fetch multiple account infos through batched `getMultipleAccount` RPC requests. Args: connection: The `solana-py` client object. pubkeys: Pubkeys to fetch. batch_size: The number of `getMultipleAccount` objects to include in each HTTP request. Returns: Account infos and pubkeys. \"\"\" pubkeys_per_network_request = _GET_MULTIPLE_ACCOUNTS_LIMIT * batch_size chunks = partition_all ( pubkeys_per_network_request , pubkeys ) awaitables = [ _get_multiple_accounts_core ( connection , pubkeys_chunk ) for pubkeys_chunk in chunks ] results = await gather ( * awaitables , return_exceptions = False ) return list ( concat ( results )) invoke ( program_id , provider , accounts = None , data = None ) async Send a transaction to a program with the given accounts and instruction data. Parameters: Name Type Description Default program_id Union[solana.publickey.PublicKey, str] The program ID required provider Provider the Provider instance. required accounts Optional[list[solana.transaction.AccountMeta]] AccountMeta objects. None data Optional[bytes] The transaction data. None Returns: Type Description <function NewType.<locals>.new_type at 0x7f4b84a328b0> The transaction signature. Source code in anchorpy/utils/rpc.py async def invoke ( program_id : AddressType , provider : Provider , accounts : Optional [ list [ AccountMeta ]] = None , data : Optional [ bytes ] = None , ) -> TransactionSignature : \"\"\"Send a transaction to a program with the given accounts and instruction data. Args: program_id: The program ID provider: the `Provider` instance. accounts: `AccountMeta` objects. data: The transaction data. Returns: The transaction signature. \"\"\" translated_program_id = translate_address ( program_id ) tx = Transaction () tx . add ( TransactionInstruction ( program_id = translated_program_id , keys = [] if accounts is None else accounts , data = bytes ( 0 ) if data is None else data , ), ) return await provider . send ( tx ) token This module contains utilities for the SPL Token Program. create_mint_and_vault ( provider , amount , owner = None , decimals = None ) async Create a mint and a vault, then mint tokens to the vault. Parameters: Name Type Description Default provider Provider An anchorpy Provider instance. required amount int The amount of tokens to mint to the vault. required owner Optional[solana.publickey.PublicKey] User account that will own the new account. None decimals Optional[int] The number of decimal places for the token to support. None Returns: Type Description tuple The mint and vault pubkeys. Source code in anchorpy/utils/token.py async def create_mint_and_vault ( provider : Provider , amount : int , owner : Optional [ PublicKey ] = None , decimals : Optional [ int ] = None , ) -> tuple [ PublicKey , PublicKey ]: \"\"\"Create a mint and a vault, then mint tokens to the vault. Args: provider: An anchorpy Provider instance. amount: The amount of tokens to mint to the vault. owner: User account that will own the new account. decimals: The number of decimal places for the token to support. Returns: The mint and vault pubkeys. \"\"\" actual_owner = provider . wallet . public_key if owner is None else owner mint = Keypair () vault = Keypair () tx = Transaction () mint_space = 82 create_mint_mbre_resp = ( await provider . connection . get_minimum_balance_for_rent_exemption ( mint_space ) ) create_mint_mbre = create_mint_mbre_resp [ \"result\" ] create_mint_account_params = CreateAccountParams ( from_pubkey = provider . wallet . public_key , new_account_pubkey = mint . public_key , space = mint_space , lamports = create_mint_mbre , program_id = TOKEN_PROGRAM_ID , ) create_mint_account_instruction = create_account ( create_mint_account_params , ) init_mint_instruction = initialize_mint ( InitializeMintParams ( mint = mint . public_key , decimals = 0 if decimals is None else decimals , mint_authority = provider . wallet . public_key , program_id = TOKEN_PROGRAM_ID , ), ) vault_space = 165 create_vault_mbre_resp = ( await provider . connection . get_minimum_balance_for_rent_exemption ( vault_space ) ) create_vault_mbre = create_vault_mbre_resp [ \"result\" ] create_vault_account_instruction = create_account ( CreateAccountParams ( from_pubkey = provider . wallet . public_key , new_account_pubkey = vault . public_key , space = vault_space , lamports = create_vault_mbre , program_id = TOKEN_PROGRAM_ID , ), ) init_vault_instruction = initialize_account ( InitializeAccountParams ( program_id = TOKEN_PROGRAM_ID , account = vault . public_key , mint = mint . public_key , owner = actual_owner , ), ) mint_to_instruction = mint_to ( MintToParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . public_key , dest = vault . public_key , amount = amount , mint_authority = provider . wallet . public_key , ), ) tx . add ( create_mint_account_instruction , init_mint_instruction , create_vault_account_instruction , init_vault_instruction , mint_to_instruction , ) await provider . send ( tx , [ mint , vault ]) return mint . public_key , vault . public_key create_token_account ( prov , mint , owner ) async Create a token account. Parameters: Name Type Description Default prov Provider An anchorpy Provider instance. required mint PublicKey The pubkey of the token's mint. required owner PublicKey User account that will own the new account. required Returns: Type Description PublicKey The pubkey of the new account. Source code in anchorpy/utils/token.py async def create_token_account ( prov : Provider , mint : PublicKey , owner : PublicKey , ) -> PublicKey : \"\"\"Create a token account. Args: prov: An anchorpy Provider instance. mint: The pubkey of the token's mint. owner: User account that will own the new account. Returns: The pubkey of the new account. \"\"\" token = AsyncToken ( prov . connection , mint , TOKEN_PROGRAM_ID , prov . wallet . payer ) return await token . create_account ( owner ) create_token_account_instrs ( provider , new_account_pubkey , mint , owner ) async Generate instructions for creating a token account. Parameters: Name Type Description Default provider Provider An anchorpy Provider instance. required new_account_pubkey PublicKey The pubkey of the new account. required mint PublicKey The pubkey of the token's mint. required owner PublicKey User account that will own the new account. required Returns: Type Description tuple Transaction instructions to create the new account. Source code in anchorpy/utils/token.py async def create_token_account_instrs ( provider : Provider , new_account_pubkey : PublicKey , mint : PublicKey , owner : PublicKey , ) -> tuple [ TransactionInstruction , TransactionInstruction ]: \"\"\"Generate instructions for creating a token account. Args: provider: An anchorpy Provider instance. new_account_pubkey: The pubkey of the new account. mint: The pubkey of the token's mint. owner: User account that will own the new account. Returns: Transaction instructions to create the new account. \"\"\" mbre_resp = await provider . connection . get_minimum_balance_for_rent_exemption ( 165 ) lamports = mbre_resp [ \"result\" ] return ( create_account ( CreateAccountParams ( from_pubkey = provider . wallet . public_key , new_account_pubkey = new_account_pubkey , space = 165 , lamports = lamports , program_id = TOKEN_PROGRAM_ID , ) ), initialize_account ( InitializeAccountParams ( account = new_account_pubkey , mint = mint , owner = owner , program_id = TOKEN_PROGRAM_ID , ) ), ) get_mint_info ( provider , addr ) async Retrieve mint information. Parameters: Name Type Description Default provider Provider The anchorpy Provider instance. required addr PublicKey The pubkey of the mint. required Returns: Type Description MintInfo The parsed MintInfo . Source code in anchorpy/utils/token.py async def get_mint_info ( provider : Provider , addr : PublicKey , ) -> MintInfo : \"\"\"Retrieve mint information. Args: provider: The anchorpy Provider instance. addr: The pubkey of the mint. Returns: The parsed `MintInfo`. \"\"\" depositor_acc_info_raw = await provider . connection . get_account_info ( addr ) return parse_mint_account ( depositor_acc_info_raw ) get_token_account ( provider , addr ) async Retrieve token account information. Parameters: Name Type Description Default provider Provider The anchorpy Provider instance. required addr PublicKey The pubkey of the token account. required Source code in anchorpy/utils/token.py async def get_token_account ( provider : Provider , addr : PublicKey ) -> AccountInfo : \"\"\"Retrieve token account information. Args: provider: The anchorpy Provider instance. addr: The pubkey of the token account. Returns: The parsed `AccountInfo` of the token account. \"\"\" depositor_acc_info_raw = await provider . connection . get_account_info ( addr ) return parse_token_account ( depositor_acc_info_raw ) parse_mint_account ( info ) Parse raw RPC response into MintInfo . Parameters: Name Type Description Default info RPCResponse The RPC response from calling .get_account_info for the mint pubkey. required Exceptions: Type Description AttributeError If the account is not owned by the Token Program. ValueError If the fetched data is the wrong size. Returns: Type Description MintInfo The parsed MintInfo . Source code in anchorpy/utils/token.py def parse_mint_account ( info : RPCResponse ) -> MintInfo : \"\"\"Parse raw RPC response into `MintInfo`. Args: info: The RPC response from calling `.get_account_info` for the mint pubkey. Raises: AttributeError: If the account is not owned by the Token Program. ValueError: If the fetched data is the wrong size. Returns: The parsed `MintInfo`. \"\"\" owner = info [ \"result\" ][ \"value\" ][ \"owner\" ] if owner != str ( TOKEN_PROGRAM_ID ): raise AttributeError ( f \"Invalid mint owner: { owner } \" ) bytes_data = decode_byte_string ( info [ \"result\" ][ \"value\" ][ \"data\" ][ 0 ]) if len ( bytes_data ) != MINT_LAYOUT . sizeof (): raise ValueError ( \"Invalid mint size\" ) decoded_data = MINT_LAYOUT . parse ( bytes_data ) decimals = decoded_data . decimals if decoded_data . mint_authority_option == 0 : mint_authority = None else : mint_authority = PublicKey ( decoded_data . mint_authority ) supply = decoded_data . supply is_initialized = decoded_data . is_initialized != 0 if decoded_data . freeze_authority_option == 0 : freeze_authority = None else : freeze_authority = PublicKey ( decoded_data . freeze_authority ) return MintInfo ( mint_authority , supply , decimals , is_initialized , freeze_authority ) parse_token_account ( info ) Parse AccountInfo from RPC response. Parameters: Name Type Description Default info RPCResponse the get_account_info RPC response. required Exceptions: Type Description ValueError If the fetched data is the wrong size. AttributeError If the account is not owned by the token program. Returns: Type Description AccountInfo The parsed AccountInfo . Source code in anchorpy/utils/token.py def parse_token_account ( info : RPCResponse ) -> AccountInfo : \"\"\"Parse `AccountInfo` from RPC response. Args: info: the `get_account_info` RPC response. Raises: ValueError: If the fetched data is the wrong size. AttributeError: If the account is not owned by the token program. Returns: The parsed `AccountInfo`. \"\"\" if not info : raise ValueError ( \"Invalid account owner\" ) if info [ \"result\" ][ \"value\" ][ \"owner\" ] != str ( TOKEN_PROGRAM_ID ): raise AttributeError ( \"Invalid account owner\" ) bytes_data = decode_byte_string ( info [ \"result\" ][ \"value\" ][ \"data\" ][ 0 ]) if len ( bytes_data ) != ACCOUNT_LAYOUT . sizeof (): raise ValueError ( \"Invalid account size\" ) decoded_data = ACCOUNT_LAYOUT . parse ( bytes_data ) mint = PublicKey ( decoded_data . mint ) owner = PublicKey ( decoded_data . owner ) amount = decoded_data . amount if decoded_data . delegate_option == 0 : delegate = None delegated_amount = 0 else : delegate = PublicKey ( decoded_data . delegate ) delegated_amount = decoded_data . delegated_amount is_initialized = decoded_data . state != 0 is_frozen = decoded_data . state == 2 if decoded_data . is_native_option == 1 : rent_exempt_reserve = decoded_data . is_native is_native = True else : rent_exempt_reserve = None is_native = False if decoded_data . close_authority_option == 0 : close_authority = None else : close_authority = PublicKey ( decoded_data . owner ) return AccountInfo ( mint , owner , amount , delegate , delegated_amount , is_initialized , is_frozen , is_native , rent_exempt_reserve , close_authority , )","title":"API Reference"},{"location":"api_reference/#api-reference","text":"","title":"API Reference"},{"location":"api_reference/#anchorpy.program.core.Program","text":"Program provides the IDL deserialized client representation of an Anchor program. This API is the one stop shop for all things related to communicating with on-chain programs. Among other things, one can send transactions, fetch deserialized accounts, decode instruction data, subscribe to account changes, and listen to events. In addition to field accessors and methods, the object provides a set of dynamically generated properties, also known as namespaces, that map one-to-one to program methods and accounts.","title":"Program"},{"location":"api_reference/#anchorpy.program.core.Program.__init__","text":"Initialize the Program object. Parameters: Name Type Description Default idl Idl The parsed IDL object. required program_id PublicKey The program ID. required provider Optional[Provider] The Provider object for the Program. Defaults to Provider.local(). None Source code in anchorpy/program/core.py def __init__ ( self , idl : Idl , program_id : PublicKey , provider : Optional [ Provider ] = None ): \"\"\"Initialize the Program object. Args: idl: The parsed IDL object. program_id: The program ID. provider: The Provider object for the Program. Defaults to Provider.local(). \"\"\" self . idl = idl self . program_id = program_id self . provider = provider if provider is not None else Provider . local () self . coder = Coder ( idl ) ( # noqa: WPS236 rpc , instruction , transaction , account , simulate , types , ) = _build_namespace ( idl , self . coder , program_id , self . provider , ) self . rpc = rpc self . instruction = instruction self . transaction = transaction self . account = account self . simulate = simulate self . type = types","title":"__init__()"},{"location":"api_reference/#anchorpy.program.core.Program.at","text":"Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's anchor idl init command. Parameters: Name Type Description Default address AddressType The program ID. required provider Optional[Provider] The network and wallet context. None Returns: Type Description Program The Program instantiated using the fetched IDL. Source code in anchorpy/program/core.py @classmethod async def at ( cls , address : AddressType , provider : Optional [ Provider ] = None , ) -> Program : \"\"\"Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's `anchor idl init` command. Args: address: The program ID. provider: The network and wallet context. Returns: The Program instantiated using the fetched IDL. \"\"\" provider_to_use = Provider . local () if provider is None else provider program_id = translate_address ( address ) idl = await cls . fetch_idl ( program_id , provider_to_use ) return cls ( idl , program_id , provider )","title":"at()"},{"location":"api_reference/#anchorpy.program.core.Program.close","text":"Use this when you are done with the client. Source code in anchorpy/program/core.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . provider . close ()","title":"close()"},{"location":"api_reference/#anchorpy.program.core.Program.fetch_idl","text":"Fetch and parse an idl from the blockchain. Parameters: Name Type Description Default address AddressType The program ID. required provider Provider The network and wallet context. required Returns: Type Description Idl The fetched IDL. Source code in anchorpy/program/core.py @classmethod async def fetch_idl ( cls , address : AddressType , provider : Provider , ) -> Idl : \"\"\"Fetch and parse an idl from the blockchain. Args: address: The program ID. provider: The network and wallet context. Returns: Idl: The fetched IDL. \"\"\" raw = await cls . fetch_raw_idl ( address , provider ) return Idl . from_json ( raw )","title":"fetch_idl()"},{"location":"api_reference/#anchorpy.program.core.Program.fetch_raw_idl","text":"Fetch an idl from the blockchain as a raw JSON dictionary. Parameters: Name Type Description Default address AddressType The program ID. required provider Provider The network and wallet context. required Exceptions: Type Description IdlNotFoundError If the requested IDL account does not exist. Returns: Type Description Idl The raw IDL. Source code in anchorpy/program/core.py @classmethod async def fetch_raw_idl ( cls , address : AddressType , provider : Provider , ) -> dict [ str , Any ]: \"\"\"Fetch an idl from the blockchain as a raw JSON dictionary. Args: address: The program ID. provider: The network and wallet context. Raises: IdlNotFoundError: If the requested IDL account does not exist. Returns: Idl: The raw IDL. \"\"\" program_id = translate_address ( address ) actual_provider = provider if provider is not None else Provider . local () idl_addr = _idl_address ( program_id ) account_info = await actual_provider . connection . get_account_info ( idl_addr ) account_info_val = account_info [ \"result\" ][ \"value\" ] if account_info_val is None : raise IdlNotFoundError ( f \"IDL not found for program: { address } \" ) idl_account = _decode_idl_account ( b64decode ( account_info_val [ \"data\" ][ 0 ])[ ACCOUNT_DISCRIMINATOR_SIZE :] ) inflated_idl = _pako_inflate ( bytes ( idl_account [ \"data\" ])) . decode () return json . loads ( inflated_idl )","title":"fetch_raw_idl()"},{"location":"api_reference/#anchorpy.provider.Provider","text":"The network and wallet context used to send transactions paid for and signed by the provider.","title":"Provider"},{"location":"api_reference/#anchorpy.provider.Provider.__init__","text":"Initialize the Provider. Parameters: Name Type Description Default connection AsyncClient The cluster connection where the program is deployed. required wallet Wallet The wallet used to pay for and sign all transactions. required opts types.TxOpts Transaction confirmation options to use by default. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed') Source code in anchorpy/provider.py def __init__ ( self , connection : AsyncClient , wallet : Wallet , opts : types . TxOpts = DEFAULT_OPTIONS , ) -> None : \"\"\"Initialize the Provider. Args: connection: The cluster connection where the program is deployed. wallet: The wallet used to pay for and sign all transactions. opts: Transaction confirmation options to use by default. \"\"\" self . connection = connection self . wallet = wallet self . opts = opts","title":"__init__()"},{"location":"api_reference/#anchorpy.provider.Provider.close","text":"Use this when you are done with the connection. Source code in anchorpy/provider.py async def close ( self ) -> None : \"\"\"Use this when you are done with the connection.\"\"\" await self . connection . close ()","title":"close()"},{"location":"api_reference/#anchorpy.provider.Provider.env","text":"Create a Provider using the ANCHOR_PROVIDER_URL environment variable. Source code in anchorpy/provider.py @classmethod def env ( cls ) -> Provider : \"\"\"Create a `Provider` using the `ANCHOR_PROVIDER_URL` environment variable.\"\"\" url = environ [ \"ANCHOR_PROVIDER_URL\" ] options = DEFAULT_OPTIONS connection = AsyncClient ( url , options . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , options )","title":"env()"},{"location":"api_reference/#anchorpy.provider.Provider.local","text":"Create a Provider with a wallet read from the local filesystem. Parameters: Name Type Description Default url Optional[str] The network cluster url. None opts types.TxOpts The default transaction confirmation options. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed') Source code in anchorpy/provider.py @classmethod def local ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` with a wallet read from the local filesystem. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , opts )","title":"local()"},{"location":"api_reference/#anchorpy.provider.Provider.send","text":"Send the given transaction, paid for and signed by the provider's wallet. Parameters: Name Type Description Default tx Transaction The transaction to send. required signers Optional[list[Keypair]] The set of signers in addition to the provider wallet that will sign the transaction. None opts types.TxOpts Transaction confirmation options. None Returns: Type Description TransactionSignature The transaction signature from the RPC server. Source code in anchorpy/provider.py async def send ( self , tx : Transaction , signers : Optional [ list [ Keypair ]] = None , opts : types . TxOpts = None , ) -> TransactionSignature : \"\"\"Send the given transaction, paid for and signed by the provider's wallet. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction signature from the RPC server. \"\"\" if signers is None : signers = [] if opts is None : opts = self . opts all_signers = list ( unique_everseen ([ self . wallet . payer ] + signers )) resp = await self . connection . send_transaction ( tx , * all_signers , opts = opts ) return resp [ \"result\" ]","title":"send()"},{"location":"api_reference/#anchorpy.provider.Provider.send_all","text":"Similar to send , but for an array of transactions and signers. Parameters: Name Type Description Default reqs list[Union[Transaction, SendTxRequest]] a list of Transaction or SendTxRequest objects. Use SendTxRequest to specify additional signers other than the wallet. required opts Optional[types.TxOpts] Transaction confirmation options. None Returns: Type Description list[TransactionSignature] The transaction signatures from the RPC server. Source code in anchorpy/provider.py async def send_all ( self , reqs : list [ Union [ Transaction , SendTxRequest ]], opts : Optional [ types . TxOpts ] = None , ) -> list [ TransactionSignature ]: \"\"\"Similar to `send`, but for an array of transactions and signers. Args: reqs: a list of Transaction or SendTxRequest objects. Use SendTxRequest to specify additional signers other than the wallet. opts: Transaction confirmation options. Returns: The transaction signatures from the RPC server. \"\"\" if opts is None : opts = self . opts txs = [] for req in reqs : signers = [] if isinstance ( req , Transaction ) else req . signers tx = req if isinstance ( req , Transaction ) else req . tx for signer in signers : tx . sign_partial ( signer ) txs . append ( tx ) signed_txs = self . wallet . sign_all_transactions ( txs ) sigs = [] for signed in signed_txs : resp = await self . connection . send_raw_transaction ( signed . serialize (), opts = opts ) sigs . append ( resp [ \"result\" ]) return sigs","title":"send_all()"},{"location":"api_reference/#anchorpy.provider.Provider.simulate","text":"Simulate the given transaction, returning emitted logs from execution. Parameters: Name Type Description Default tx Transaction The transaction to send. required signers Optional[list[Keypair]] The set of signers in addition to the provider wallet that will sign the transaction. None opts types.TxOpts Transaction confirmation options. None Returns: Type Description types.RPCResponse The transaction signature from the RPC server. Source code in anchorpy/provider.py async def simulate ( self , tx : Transaction , signers : Optional [ list [ Keypair ]] = None , opts : types . TxOpts = None , ) -> types . RPCResponse : \"\"\"Simulate the given transaction, returning emitted logs from execution. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction signature from the RPC server. \"\"\" if signers is None : signers = [] if opts is None : opts = self . opts recent_blockhash_resp = await self . connection . get_recent_blockhash ( Finalized , ) tx . recent_blockhash = recent_blockhash_resp [ \"result\" ][ \"value\" ][ \"blockhash\" ] all_signers = list ( unique_everseen ([ self . wallet . payer ] + signers )) tx . sign ( * all_signers ) return await self . connection . simulate_transaction ( tx , sig_verify = True , commitment = opts . preflight_commitment )","title":"simulate()"},{"location":"api_reference/#anchorpy.program.context.Context","text":"Context provides all non-argument inputs for generating Anchor transactions. Attributes: Name Type Description accounts Dict[str, Any] The accounts used in the instruction context. remaining_accounts List[solana.transaction.AccountMeta] All accounts to pass into an instruction after the main signers List[solana.keypair.Keypair] Accounts that must sign a given transaction. pre_instructions List[solana.transaction.TransactionInstruction] Instructions to run before a given method. Often this is used, for example to create accounts prior to executing a method. post_instructions List[solana.transaction.TransactionInstruction] Instructions to run after a given method. Often this is used, for example to close accounts prior to executing a method. options Optional[solana.rpc.types.TxOpts] Commitment parameters to use for a transaction.","title":"Context"},{"location":"api_reference/#anchorpy.workspace.create_workspace","text":"Get a workspace from the provided path to the project root. Parameters: Name Type Description Default path Union[pathlib.Path, str] The path to the project root. Defaults to the current working directory if omitted. None url Optional[str] The URL of the JSON RPC. Defaults to http://localhost:8899. None Returns: Type Description Dict[str, anchorpy.program.core.Program] Mapping of program name to Program object. Source code in anchorpy/workspace.py def create_workspace ( path : Optional [ Union [ Path , str ]] = None , url : Optional [ str ] = None ) -> WorkspaceType : \"\"\"Get a workspace from the provided path to the project root. Args: path: The path to the project root. Defaults to the current working directory if omitted. url: The URL of the JSON RPC. Defaults to http://localhost:8899. Returns: Mapping of program name to Program object. \"\"\" result = {} project_root = Path . cwd () if path is None else Path ( path ) idl_folder = project_root / \"target/idl\" for file in idl_folder . iterdir (): with file . open () as f : idl_dict = json . load ( f ) idl = Idl . from_json ( idl_dict ) metadata = cast ( _Metadata , idl . metadata ) program = Program ( idl , PublicKey ( metadata . address ), Provider . local ( url )) result [ idl . name ] = program return result","title":"create_workspace()"},{"location":"api_reference/#anchorpy.workspace.close_workspace","text":"Close the HTTP clients of all the programs in the workspace. Parameters: Name Type Description Default workspace Dict[str, anchorpy.program.core.Program] The workspace to close. required Source code in anchorpy/workspace.py async def close_workspace ( workspace : WorkspaceType ) -> None : \"\"\"Close the HTTP clients of all the programs in the workspace. Args: workspace: The workspace to close. \"\"\" for program in workspace . values (): # could do this in a faster way but there's probably no point. await program . close ()","title":"close_workspace()"},{"location":"api_reference/#anchorpy.idl.Idl","text":"A parsed IDL object.","title":"Idl"},{"location":"api_reference/#anchorpy.idl.Idl.from_json","text":"Generate a parsed IDL from a JSON dict. Parameters: Name Type Description Default idl Dict[str, Any] The raw IDL dict. required Returns: Type Description Idl The parsed Idl object. Source code in anchorpy/idl.py @classmethod def from_json ( cls , idl : Dict [ str , Any ]) -> \"Idl\" : \"\"\"Generate a parsed IDL from a JSON dict. Args: idl: The raw IDL dict. Returns: The parsed Idl object. \"\"\" return deserialize ( cls , idl )","title":"from_json()"},{"location":"api_reference/#anchorpy.pytest_plugin.workspace_fixture","text":"Create a fixture that sets up and tears down a localnet instance and returns a workspace dict. Equivalent to combining localnet_fixture , create_workspace and close_workspace . Parameters: Name Type Description Default path Union[pathlib.Path, str] Path to root of the Anchor project. required scope str Pytest fixture scope. 'module' timeout_seconds int Time to wait for Anchor localnet to start. 60 build_cmd Optional[str] Command to run before anchor localnet . Defaults to anchor build . None Returns: Type Description Callable A workspace fixture for use with pytest. Source code in anchorpy/pytest_plugin.py def workspace_fixture ( path : Union [ Path , str ], scope : str = \"module\" , timeout_seconds : int = 60 , build_cmd : Optional [ str ] = None , ) -> Callable : \"\"\"Create a fixture that sets up and tears down a localnet instance and returns a workspace dict. Equivalent to combining `localnet_fixture`, `create_workspace` and `close_workspace`. Args: path: Path to root of the Anchor project. scope: Pytest fixture scope. timeout_seconds: Time to wait for Anchor localnet to start. build_cmd: Command to run before `anchor localnet`. Defaults to `anchor build`. Returns: A workspace fixture for use with pytest. \"\"\" # noqa: E501,D202 @fixture ( scope = scope ) async def _workspace_fixture ( _fixed_xprocess , ) -> AsyncGenerator [ dict [ str , Program ], None ]: class Starter ( ProcessStarter ): # startup pattern pattern = \"JSON RPC URL\" terminate_on_interrupt = True # command to start process args = [ \"anchor\" , \"localnet\" , \"--skip-build\" ] timeout = timeout_seconds popen_kwargs = { \"cwd\" : path , \"start_new_session\" : True , } max_read_lines = 1_000 # command to start process actual_build_cmd = \"anchor build\" if build_cmd is None else build_cmd subprocess . run ( actual_build_cmd , cwd = path , check = True , shell = True ) # noqa: S603 # ensure process is running _ = _fixed_xprocess . ensure ( \"localnet\" , Starter ) ws = create_workspace ( path ) yield ws await close_workspace ( ws ) # clean up whole process tree afterwards _fixed_xprocess . getinfo ( \"localnet\" ) . terminate () return _workspace_fixture","title":"workspace_fixture()"},{"location":"api_reference/#anchorpy.pytest_plugin.localnet_fixture","text":"Create a fixture that sets up and tears down a localnet instance with workspace programs deployed. Parameters: Name Type Description Default path Path Path to root of the Anchor project. required scope str Pytest fixture scope. 'module' timeout_seconds int Time to wait for Anchor localnet to start. 60 build_cmd Optional[str] Command to run before anchor localnet . Defaults to anchor build . None Returns: Type Description Callable A localnet fixture for use with pytest. Source code in anchorpy/pytest_plugin.py def localnet_fixture ( path : Path , scope : str = \"module\" , timeout_seconds : int = 60 , build_cmd : Optional [ str ] = None , ) -> Callable : \"\"\"Create a fixture that sets up and tears down a localnet instance with workspace programs deployed. Args: path: Path to root of the Anchor project. scope: Pytest fixture scope. timeout_seconds: Time to wait for Anchor localnet to start. build_cmd: Command to run before `anchor localnet`. Defaults to `anchor build`. Returns: A localnet fixture for use with pytest. \"\"\" # noqa: E501,D202 @fixture ( scope = scope ) def _localnet_fixture ( _fixed_xprocess ): class Starter ( ProcessStarter ): # startup pattern pattern = \"JSON RPC URL\" terminate_on_interrupt = True # command to start process args = [ \"anchor\" , \"localnet\" , \"--skip-build\" ] timeout = timeout_seconds popen_kwargs = { \"cwd\" : path , \"start_new_session\" : True , } max_read_lines = 1_000 # command to start process actual_build_cmd = \"anchor build\" if build_cmd is None else build_cmd subprocess . run ( actual_build_cmd , cwd = path , check = True , shell = True ) # noqa: S603 # ensure process is running and return its logfile logfile = _fixed_xprocess . ensure ( \"localnet\" , Starter ) yield logfile # clean up whole process tree afterwards _fixed_xprocess . getinfo ( \"localnet\" ) . terminate () return _localnet_fixture","title":"localnet_fixture()"},{"location":"api_reference/#anchorpy.provider.Wallet","text":"Python wallet object.","title":"Wallet"},{"location":"api_reference/#anchorpy.provider.Wallet.public_key","text":"Get the public key of the wallet.","title":"public_key"},{"location":"api_reference/#anchorpy.provider.Wallet.__init__","text":"Initialize the wallet. Parameters: Name Type Description Default payer Keypair the Keypair used to sign transactions. required Source code in anchorpy/provider.py def __init__ ( self , payer : Keypair ): \"\"\"Initialize the wallet. Args: payer: the Keypair used to sign transactions. \"\"\" self . payer = payer","title":"__init__()"},{"location":"api_reference/#anchorpy.provider.Wallet.local","text":"Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. Source code in anchorpy/provider.py @classmethod def local ( cls ) -> Wallet : \"\"\"Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. \"\"\" path = Path ( getenv ( \"ANCHOR_WALLET\" , Path . home () / \".config/solana/id.json\" )) with path . open () as f : keypair = json . load ( f ) return cls ( Keypair . from_secret_key ( bytes ( keypair )))","title":"local()"},{"location":"api_reference/#anchorpy.provider.Wallet.sign_all_transactions","text":"Sign a list of transactions using the wallet's keypair. Parameters: Name Type Description Default txs list[Transaction] The transactions to sign. required Returns: Type Description list[Transaction] The signed transactions. Source code in anchorpy/provider.py def sign_all_transactions ( self , txs : list [ Transaction ]) -> list [ Transaction ]: \"\"\"Sign a list of transactions using the wallet's keypair. Args: txs: The transactions to sign. Returns: The signed transactions. \"\"\" for tx in txs : tx . sign_partial ( self . payer ) return txs","title":"sign_all_transactions()"},{"location":"api_reference/#anchorpy.provider.Wallet.sign_transaction","text":"Sign a transaction using the wallet's keypair. Parameters: Name Type Description Default tx Transaction The transaction to sign. required Returns: Type Description Transaction The signed transaction. Source code in anchorpy/provider.py def sign_transaction ( self , tx : Transaction ) -> Transaction : \"\"\"Sign a transaction using the wallet's keypair. Args: tx: The transaction to sign. Returns: The signed transaction. \"\"\" tx . sign ( self . payer ) return tx","title":"sign_transaction()"},{"location":"api_reference/#anchorpy.provider.SendTxRequest","text":"Use this to provide custom signers to Provider.send_all . Attributes: Name Type Description tx Transaction The Transaction to send. signers List[solana.keypair.Keypair] Custom signers for the transaction.","title":"SendTxRequest"},{"location":"api_reference/#anchorpy.coder.coder.Coder","text":"Coder provides a facade for encoding and decoding all IDL related objects.","title":"Coder"},{"location":"api_reference/#anchorpy.coder.coder.Coder.__init__","text":"Initialize the coder. Parameters: Name Type Description Default idl Idl a parsed Idl instance. required Source code in anchorpy/coder/coder.py def __init__ ( self , idl : Idl ): \"\"\"Initialize the coder. Args: idl: a parsed Idl instance. \"\"\" self . instruction : InstructionCoder = InstructionCoder ( idl ) self . accounts : AccountsCoder = AccountsCoder ( idl ) self . events : EventCoder = EventCoder ( idl )","title":"__init__()"},{"location":"api_reference/#anchorpy.coder.instruction.InstructionCoder","text":"Encodes and decodes program instructions.","title":"InstructionCoder"},{"location":"api_reference/#anchorpy.coder.instruction.InstructionCoder.__init__","text":"Init. Parameters: Name Type Description Default idl Idl The parsed IDL object. required Source code in anchorpy/coder/instruction.py def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . ix_layout = _parse_ix_layout ( idl ) sighasher = _Sighash () sighash_layouts : Dict [ bytes , Construct ] = {} sighashes : Dict [ str , bytes ] = {} sighash_to_name : Dict [ bytes , str ] = {} for ix in idl . instructions : sh = sighasher . build ( ix . name ) sighashes [ ix . name ] = sh sighash_layouts [ sh ] = self . ix_layout [ ix . name ] sighash_to_name [ sh ] = ix . name self . sighash_layouts = sighash_layouts self . sighashes = sighashes self . sighash_to_name = sighash_to_name subcon = Sequence ( \"sighash\" / Bytes ( 8 ), Switch ( lambda this : this . sighash , sighash_layouts ), ) super () . __init__ ( subcon ) # type: ignore","title":"__init__()"},{"location":"api_reference/#anchorpy.coder.instruction.InstructionCoder.encode","text":"Encode a program instruction. Parameters: Name Type Description Default ix_name str The name of the instruction required ix Dict[str, Any] The data to encode. required Returns: Type Description bytes The encoded instruction. Source code in anchorpy/coder/instruction.py def encode ( self , ix_name : str , ix : Dict [ str , Any ]) -> bytes : \"\"\"Encode a program instruction. Args: ix_name: The name of the instruction ix: The data to encode. Returns: The encoded instruction. \"\"\" return self . build ( Instruction ( name = ix_name , data = ix ))","title":"encode()"},{"location":"api_reference/#anchorpy.coder.event.EventCoder","text":"Encodes and decodes Anchor events.","title":"EventCoder"},{"location":"api_reference/#anchorpy.coder.event.EventCoder.__init__","text":"Initialize the EventCoder. Parameters: Name Type Description Default idl Idl The parsed Idl object. required Source code in anchorpy/coder/event.py def __init__ ( self , idl : Idl ): \"\"\"Initialize the EventCoder. Args: idl: The parsed Idl object. \"\"\" self . idl = idl idl_events = idl . events layouts : Dict [ str , Construct ] if idl_events : layouts = { event . name : _event_layout ( event , idl ) for event in idl_events } else : layouts = {} self . layouts = layouts self . discriminators : Dict [ bytes , str ] = { _event_discriminator ( event . name ): event . name for event in idl_events } self . discriminator_to_layout = { disc : self . layouts [ event_name ] for disc , event_name in self . discriminators . items () } subcon = Sequence ( \"discriminator\" / Bytes ( 8 ), # not base64-encoded here Switch ( lambda this : this . discriminator , self . discriminator_to_layout ), ) super () . __init__ ( subcon ) # type: ignore","title":"__init__()"},{"location":"api_reference/#anchorpy.coder.accounts.AccountsCoder","text":"Encodes and decodes account data.","title":"AccountsCoder"},{"location":"api_reference/#anchorpy.coder.accounts.AccountsCoder.__init__","text":"Init. Parameters: Name Type Description Default idl Idl The parsed IDL object. required Source code in anchorpy/coder/accounts.py def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . _accounts_layout = { acc . name : _typedef_layout ( acc , idl . types , acc . name ) for acc in idl . accounts } self . acc_name_to_discriminator = { acc . name : _account_discriminator ( acc . name ) for acc in idl . accounts } self . discriminator_to_acc_name = { disc : acc_name for acc_name , disc in self . acc_name_to_discriminator . items () } discriminator_to_typedef_layout = { disc : self . _accounts_layout [ acc_name ] for acc_name , disc in self . acc_name_to_discriminator . items () } subcon = Sequence ( \"discriminator\" / Bytes ( ACCOUNT_DISCRIMINATOR_SIZE ), Switch ( lambda this : this . discriminator , discriminator_to_typedef_layout ), ) super () . __init__ ( subcon ) # type: ignore","title":"__init__()"},{"location":"api_reference/#anchorpy.coder.accounts.AccountsCoder.decode","text":"Decode account data. Parameters: Name Type Description Default obj bytes Data to decode. required Returns: Type Description Container Decoded data. Source code in anchorpy/coder/accounts.py def decode ( self , obj : bytes ) -> Container [ Any ]: \"\"\"Decode account data. Args: obj: Data to decode. Returns: Decoded data. \"\"\" return self . parse ( obj ) . data","title":"decode()"},{"location":"api_reference/#anchorpy.program.common.Instruction","text":"Container for a named instruction. Attributes: Name Type Description data Union[Dict[str, Any], construct.lib.containers.Container[Any]] The actual instruction data. name str The name of the instruction.","title":"Instruction"},{"location":"api_reference/#anchorpy.idl.IdlProgramAccount","text":"The on-chain account of the IDL.","title":"IdlProgramAccount"},{"location":"api_reference/#anchorpy.program.common.Event","text":"A parsed event object.","title":"Event"},{"location":"api_reference/#anchorpy.program.common.translate_address","text":"Convert str | PublicKey into PublicKey . Parameters: Name Type Description Default address Union[solana.publickey.PublicKey, str] Public key as string or PublicKey . required Returns: Type Description PublicKey Public key as PublicKey . Source code in anchorpy/program/common.py def translate_address ( address : AddressType ) -> PublicKey : \"\"\"Convert `str | PublicKey` into `PublicKey`. Args: address: Public key as string or `PublicKey`. Returns: Public key as `PublicKey`. \"\"\" if isinstance ( address , str ): return PublicKey ( address ) return address","title":"translate_address()"},{"location":"api_reference/#anchorpy.program.common.validate_accounts","text":"Check that accounts passed in ctx match the IDL. Parameters: Name Type Description Default ix_accounts list Accounts from the IDL. required accounts Dict[str, Any] Accounts from the ctx arg. required Exceptions: Type Description ValueError If ctx accounts don't match the IDL. Source code in anchorpy/program/common.py def validate_accounts ( ix_accounts : list [ _IdlAccountItem ], accounts : Accounts ): \"\"\"Check that accounts passed in `ctx` match the IDL. Args: ix_accounts: Accounts from the IDL. accounts: Accounts from the `ctx` arg. Raises: ValueError: If `ctx` accounts don't match the IDL. \"\"\" for acc in ix_accounts : if isinstance ( acc , get_args ( _IdlAccounts )): idl_accounts = cast ( _IdlAccounts , acc ) validate_accounts ( idl_accounts . accounts , accounts [ acc . name ]) elif acc . name not in accounts : raise ValueError ( f \"Invalid arguments: { acc . name } not provided\" )","title":"validate_accounts()"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient","text":"Provides methods for fetching and creating accounts.","title":"AccountClient"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.coder","text":"Return the coder.","title":"coder"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.program_id","text":"Return the program ID owning all accounts.","title":"program_id"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.provider","text":"Return the client's wallet and network provider.","title":"provider"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.size","text":"Return the number of bytes in this account.","title":"size"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.__init__","text":"Init. Parameters: Name Type Description Default idl Idl the parsed IDL object. required idl_account _IdlTypeDef the account definition from the IDL. required coder Coder The program's Coder object. required program_id PublicKey the program ID. required provider Provider The Provider object for the Program. required Source code in anchorpy/program/namespace/account.py def __init__ ( self , idl : Idl , idl_account : _IdlTypeDef , coder : Coder , program_id : PublicKey , provider : Provider , ): \"\"\"Init. Args: idl: the parsed IDL object. idl_account: the account definition from the IDL. coder: The program's Coder object. program_id: the program ID. provider: The Provider object for the Program. \"\"\" self . _idl_account = idl_account self . _program_id = program_id self . _provider = provider self . _coder = coder self . _size = ACCOUNT_DISCRIMINATOR_SIZE + _account_size ( idl , idl_account )","title":"__init__()"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.all","text":"Return all instances of this account type for the program. Parameters: Name Type Description Default buffer Optional[bytes] bytes filter to append to the discriminator. None memcmp_opts Optional[list[solana.rpc.types.MemcmpOpts]] Options to compare a provided series of bytes with program account data at a particular offset. None data_size Optional[int] Option to compare the program account data length with the provided data size. None Source code in anchorpy/program/namespace/account.py async def all ( self , buffer : Optional [ bytes ] = None , memcmp_opts : Optional [ list [ MemcmpOpts ]] = None , data_size : Optional [ int ] = None , ) -> list [ ProgramAccount ]: \"\"\"Return all instances of this account type for the program. Args: buffer: bytes filter to append to the discriminator. memcmp_opts: Options to compare a provided series of bytes with program account data at a particular offset. data_size: Option to compare the program account data length with the provided data size. \"\"\" all_accounts = [] discriminator = _account_discriminator ( self . _idl_account . name ) to_encode = discriminator if buffer is None else discriminator + buffer bytes_arg = b58encode ( to_encode ) . decode ( \"ascii\" ) base_memcmp_opt = MemcmpOpts ( offset = 0 , bytes = bytes_arg , ) extra_memcmpm_opts = [] if memcmp_opts is None else memcmp_opts full_memcmp_opts = [ base_memcmp_opt ] + extra_memcmpm_opts resp = await self . _provider . connection . get_program_accounts ( self . _program_id , encoding = \"base64\" , commitment = self . provider . connection . _commitment , # noqa: WPS437 data_size = data_size , memcmp_opts = full_memcmp_opts , ) for r in resp [ \"result\" ]: account_data = r [ \"account\" ][ \"data\" ][ 0 ] account_data = base64 . b64decode ( account_data ) all_accounts . append ( ProgramAccount ( public_key = PublicKey ( r [ \"pubkey\" ]), account = self . _coder . accounts . decode ( account_data ), ), ) return all_accounts","title":"all()"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.create_instruction","text":"Return an instruction for creating this account. Parameters: Name Type Description Default signer Keypair [description] required size_override int Optional override for the account size. Defaults to 0. 0 Returns: Type Description TransactionInstruction The instruction to create the account. Source code in anchorpy/program/namespace/account.py async def create_instruction ( self , signer : Keypair , size_override : int = 0 , ) -> TransactionInstruction : \"\"\"Return an instruction for creating this account. Args: signer: [description] size_override: Optional override for the account size. Defaults to 0. Returns: The instruction to create the account. \"\"\" space = size_override if size_override else self . _size mbre_resp = ( await self . _provider . connection . get_minimum_balance_for_rent_exemption ( space ) ) return create_account ( CreateAccountParams ( from_pubkey = self . _provider . wallet . public_key , new_account_pubkey = signer . public_key , space = space , lamports = mbre_resp [ \"result\" ], program_id = self . _program_id , ) )","title":"create_instruction()"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.fetch","text":"Return a deserialized account. Parameters: Name Type Description Default address PublicKey The address of the account to fetch. required Exceptions: Type Description AccountDoesNotExistError If the account doesn't exist. AccountInvalidDiscriminator If the discriminator doesn't match the IDL. Source code in anchorpy/program/namespace/account.py async def fetch ( self , address : PublicKey ) -> Container [ Any ]: \"\"\"Return a deserialized account. Args: address: The address of the account to fetch. Raises: AccountDoesNotExistError: If the account doesn't exist. AccountInvalidDiscriminator: If the discriminator doesn't match the IDL. \"\"\" account_info = await self . _provider . connection . get_account_info ( address , encoding = \"base64\" , ) if not account_info [ \"result\" ][ \"value\" ]: raise AccountDoesNotExistError ( f \"Account { address } does not exist\" ) data = base64 . b64decode ( account_info [ \"result\" ][ \"value\" ][ \"data\" ][ 0 ]) discriminator = _account_discriminator ( self . _idl_account . name ) if discriminator != data [: ACCOUNT_DISCRIMINATOR_SIZE ]: msg = f \"Account { address } has an invalid discriminator\" raise AccountInvalidDiscriminator ( msg ) return self . _coder . accounts . decode ( data )","title":"fetch()"},{"location":"api_reference/#anchorpy.program.namespace.account.AccountClient.fetch_multiple","text":"Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Parameters: Name Type Description Default addresses List[solana.publickey.PublicKey] The addresses of the accounts to fetch. required batch_size int The number of getMultipleAccounts objects to send in each HTTP request. 300 Source code in anchorpy/program/namespace/account.py async def fetch_multiple ( self , addresses : List [ PublicKey ], batch_size : int = 300 ) -> list [ Optional [ Container [ Any ]]]: \"\"\"Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Args: addresses: The addresses of the accounts to fetch. batch_size: The number of `getMultipleAccounts` objects to send in each HTTP request. \"\"\" accounts = await get_multiple_accounts ( self . _provider . connection , addresses , batch_size = batch_size , ) discriminator = _account_discriminator ( self . _idl_account . name ) result : list [ Optional [ Container [ Any ]]] = [] for account in accounts : if account is None : result . append ( None ) elif discriminator == account . account . data [: 8 ]: result . append ( self . _coder . accounts . decode ( account . account . data )) else : result . append ( None ) return result","title":"fetch_multiple()"},{"location":"api_reference/#anchorpy.program.namespace.account.ProgramAccount","text":"Deserialized account owned by a program.","title":"ProgramAccount"},{"location":"api_reference/#anchorpy.program.event.EventParser","text":"Parser to handle on_logs callbacks.","title":"EventParser"},{"location":"api_reference/#anchorpy.program.event.EventParser.handle_log","text":"Main log handler. Parameters: Name Type Description Default execution _ExecutionContext The execution stack. required log str log string from the RPC node. required Returns: Type Description tuple A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). Source code in anchorpy/program/event.py def handle_log ( self , execution : _ExecutionContext , log : str , ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Main log handler. Args: execution: The execution stack. log: log string from the RPC node. Returns: A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). \"\"\" # noqa: D401 # Executing program is this program. if execution . stack and execution . program () == str ( self . program_id ): return self . handle_program_log ( log ) # Executing program is not this program. return ( None , * self . handle_system_log ( log ))","title":"handle_log()"},{"location":"api_reference/#anchorpy.program.event.EventParser.handle_program_log","text":"Handle logs from this program. Parameters: Name Type Description Default log str log string from the RPC node. required Source code in anchorpy/program/event.py def handle_program_log ( self , log : str ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Handle logs from *this* program. Args: log: log string from the RPC node. \"\"\" # This is a `msg!` log. if log . startswith ( \"Program log:\" ): log_str = log [ LOG_START_INDEX :] try : decoded = b64decode ( log_str ) except binascii . Error : return None , None , False event = self . coder . events . parse ( decoded ) return event , None , False return ( None , * self . handle_system_log ( log ))","title":"handle_program_log()"},{"location":"api_reference/#anchorpy.program.event.EventParser.handle_system_log","text":"Handle logs when the current program being executing is not this. Parameters: Name Type Description Default log str log string from the RPC node. required Source code in anchorpy/program/event.py def handle_system_log ( self , log : str ) -> tuple [ Optional [ str ], bool ]: \"\"\"Handle logs when the current program being executing is *not* this. Args: log: log string from the RPC node. \"\"\" log_start = log . split ( \":\" )[ 0 ] splitted = log_start . split ( \" \" ) invoke_msg = f \"Program { str ( self . program_id ) } invoke\" # noqa: WPS237 if len ( splitted ) == 3 and splitted [ 0 ] == \"Program\" and splitted [ 2 ] == \"success\" : return None , True if log_start . startswith ( invoke_msg ): return str ( self . program_id ), False if \"invoke\" in log_start : return \"cpi\" , False return None , False","title":"handle_system_log()"},{"location":"api_reference/#anchorpy.program.event.EventParser.parse_logs","text":"Parse a list of logs using a provided callback. Parameters: Name Type Description Default logs List[str] The logs to parse. required callback Callable[[anchorpy.program.common.Event], NoneType] The function to handle the parsed log. required Source code in anchorpy/program/event.py def parse_logs ( self , logs : List [ str ], callback : Callable [[ Event ], None ]) -> None : \"\"\"Parse a list of logs using a provided callback. Args: logs: The logs to parse. callback: The function to handle the parsed log. \"\"\" log_scanner = _LogScanner ( logs ) execution = _ExecutionContext ( cast ( str , log_scanner . to_next ())) log = log_scanner . to_next () while log is not None : event , new_program , did_pop = self . handle_log ( execution , log ) if event is not None : callback ( event ) if new_program is not None : execution . push ( new_program ) if did_pop : execution . pop () log = log_scanner . to_next ()","title":"parse_logs()"},{"location":"api_reference/#anchorpy.program.namespace.simulate.SimulateResponse","text":"The result of a simulate function call.","title":"SimulateResponse"},{"location":"api_reference/#anchorpy.error","text":"This module handles AnchorPy errors.","title":"error"},{"location":"api_reference/#anchorpy.error.AccountDoesNotExistError","text":"Raise if account doesn't exist.","title":"AccountDoesNotExistError"},{"location":"api_reference/#anchorpy.error.AccountInvalidDiscriminator","text":"Raise if account discriminator doesn't match the IDL.","title":"AccountInvalidDiscriminator"},{"location":"api_reference/#anchorpy.error.ArgsError","text":"Raise when the incorrect number of args is passed to the RPC function.","title":"ArgsError"},{"location":"api_reference/#anchorpy.error.IdlNotFoundError","text":"Raise when requested IDL account does not exist.","title":"IdlNotFoundError"},{"location":"api_reference/#anchorpy.error.ProgramError","text":"An error from a user defined program.","title":"ProgramError"},{"location":"api_reference/#anchorpy.error.ProgramError.__init__","text":"Init. Parameters: Name Type Description Default code int The error code. required msg str The error message. required Source code in anchorpy/error.py def __init__ ( self , code : int , msg : str ) -> None : \"\"\"Init. Args: code: The error code. msg: The error message. \"\"\" self . code = code self . msg = msg super () . __init__ ( f \" { code } : { msg } \" )","title":"__init__()"},{"location":"api_reference/#anchorpy.error.ProgramError.parse","text":"Convert an RPC error into a ProgramError, if possible. Parameters: Name Type Description Default err_info Union[RPCError, _ExtendedRPCError] The plain RPC error. required idl_errors dict[int, str] Errors from the IDL file. required Returns: Type Description Optional[ProgramError] A ProgramError or None. Source code in anchorpy/error.py @classmethod def parse ( cls , err_info : Union [ RPCError , _ExtendedRPCError ], idl_errors : dict [ int , str ], ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The plain RPC error. idl_errors: Errors from the IDL file. Returns: A ProgramError or None. \"\"\" try : # noqa: WPS229 err_data = cast ( _ExtendedRPCError , err_info )[ \"data\" ] custom_err_code = err_data [ \"err\" ][ \"InstructionError\" ][ 1 ][ \"Custom\" ] except ( KeyError , TypeError ): return None # parse user error msg = idl_errors . get ( custom_err_code ) if msg is not None : return ProgramError ( custom_err_code , msg ) # parse framework internal error msg = LangErrorMessage . get ( custom_err_code ) if msg is not None : return ProgramError ( custom_err_code , msg ) # Unable to parse the error. Just return the untranslated error. return None","title":"parse()"},{"location":"api_reference/#anchorpy.utils","text":"Various utility functions.","title":"utils"},{"location":"api_reference/#anchorpy.utils.rpc","text":"This module contains the invoke function.","title":"rpc"},{"location":"api_reference/#anchorpy.utils.rpc.AccountInfo","text":"Information describing an account. Attributes: Name Type Description executable bool True if this account's data contains a loaded program. owner PublicKey Identifier of the program that owns the account. lamports int Number of lamports assigned to the account. data bytes Optional data assigned to the account. rent_epoch Optional[int] Optional rent epoch info for for account.","title":"AccountInfo"},{"location":"api_reference/#anchorpy.utils.rpc.get_multiple_accounts","text":"Fetch multiple account infos through batched getMultipleAccount RPC requests. Parameters: Name Type Description Default connection AsyncClient The solana-py client object. required pubkeys list Pubkeys to fetch. required batch_size int The number of getMultipleAccount objects to include in each HTTP request. 3 Returns: Type Description list Account infos and pubkeys. Source code in anchorpy/utils/rpc.py async def get_multiple_accounts ( connection : AsyncClient , pubkeys : list [ PublicKey ], batch_size : int = 3 ) -> list [ Optional [ _MultipleAccountsItem ]]: \"\"\"Fetch multiple account infos through batched `getMultipleAccount` RPC requests. Args: connection: The `solana-py` client object. pubkeys: Pubkeys to fetch. batch_size: The number of `getMultipleAccount` objects to include in each HTTP request. Returns: Account infos and pubkeys. \"\"\" pubkeys_per_network_request = _GET_MULTIPLE_ACCOUNTS_LIMIT * batch_size chunks = partition_all ( pubkeys_per_network_request , pubkeys ) awaitables = [ _get_multiple_accounts_core ( connection , pubkeys_chunk ) for pubkeys_chunk in chunks ] results = await gather ( * awaitables , return_exceptions = False ) return list ( concat ( results ))","title":"get_multiple_accounts()"},{"location":"api_reference/#anchorpy.utils.rpc.invoke","text":"Send a transaction to a program with the given accounts and instruction data. Parameters: Name Type Description Default program_id Union[solana.publickey.PublicKey, str] The program ID required provider Provider the Provider instance. required accounts Optional[list[solana.transaction.AccountMeta]] AccountMeta objects. None data Optional[bytes] The transaction data. None Returns: Type Description <function NewType.<locals>.new_type at 0x7f4b84a328b0> The transaction signature. Source code in anchorpy/utils/rpc.py async def invoke ( program_id : AddressType , provider : Provider , accounts : Optional [ list [ AccountMeta ]] = None , data : Optional [ bytes ] = None , ) -> TransactionSignature : \"\"\"Send a transaction to a program with the given accounts and instruction data. Args: program_id: The program ID provider: the `Provider` instance. accounts: `AccountMeta` objects. data: The transaction data. Returns: The transaction signature. \"\"\" translated_program_id = translate_address ( program_id ) tx = Transaction () tx . add ( TransactionInstruction ( program_id = translated_program_id , keys = [] if accounts is None else accounts , data = bytes ( 0 ) if data is None else data , ), ) return await provider . send ( tx )","title":"invoke()"},{"location":"api_reference/#anchorpy.utils.token","text":"This module contains utilities for the SPL Token Program.","title":"token"},{"location":"api_reference/#anchorpy.utils.token.create_mint_and_vault","text":"Create a mint and a vault, then mint tokens to the vault. Parameters: Name Type Description Default provider Provider An anchorpy Provider instance. required amount int The amount of tokens to mint to the vault. required owner Optional[solana.publickey.PublicKey] User account that will own the new account. None decimals Optional[int] The number of decimal places for the token to support. None Returns: Type Description tuple The mint and vault pubkeys. Source code in anchorpy/utils/token.py async def create_mint_and_vault ( provider : Provider , amount : int , owner : Optional [ PublicKey ] = None , decimals : Optional [ int ] = None , ) -> tuple [ PublicKey , PublicKey ]: \"\"\"Create a mint and a vault, then mint tokens to the vault. Args: provider: An anchorpy Provider instance. amount: The amount of tokens to mint to the vault. owner: User account that will own the new account. decimals: The number of decimal places for the token to support. Returns: The mint and vault pubkeys. \"\"\" actual_owner = provider . wallet . public_key if owner is None else owner mint = Keypair () vault = Keypair () tx = Transaction () mint_space = 82 create_mint_mbre_resp = ( await provider . connection . get_minimum_balance_for_rent_exemption ( mint_space ) ) create_mint_mbre = create_mint_mbre_resp [ \"result\" ] create_mint_account_params = CreateAccountParams ( from_pubkey = provider . wallet . public_key , new_account_pubkey = mint . public_key , space = mint_space , lamports = create_mint_mbre , program_id = TOKEN_PROGRAM_ID , ) create_mint_account_instruction = create_account ( create_mint_account_params , ) init_mint_instruction = initialize_mint ( InitializeMintParams ( mint = mint . public_key , decimals = 0 if decimals is None else decimals , mint_authority = provider . wallet . public_key , program_id = TOKEN_PROGRAM_ID , ), ) vault_space = 165 create_vault_mbre_resp = ( await provider . connection . get_minimum_balance_for_rent_exemption ( vault_space ) ) create_vault_mbre = create_vault_mbre_resp [ \"result\" ] create_vault_account_instruction = create_account ( CreateAccountParams ( from_pubkey = provider . wallet . public_key , new_account_pubkey = vault . public_key , space = vault_space , lamports = create_vault_mbre , program_id = TOKEN_PROGRAM_ID , ), ) init_vault_instruction = initialize_account ( InitializeAccountParams ( program_id = TOKEN_PROGRAM_ID , account = vault . public_key , mint = mint . public_key , owner = actual_owner , ), ) mint_to_instruction = mint_to ( MintToParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . public_key , dest = vault . public_key , amount = amount , mint_authority = provider . wallet . public_key , ), ) tx . add ( create_mint_account_instruction , init_mint_instruction , create_vault_account_instruction , init_vault_instruction , mint_to_instruction , ) await provider . send ( tx , [ mint , vault ]) return mint . public_key , vault . public_key","title":"create_mint_and_vault()"},{"location":"api_reference/#anchorpy.utils.token.create_token_account","text":"Create a token account. Parameters: Name Type Description Default prov Provider An anchorpy Provider instance. required mint PublicKey The pubkey of the token's mint. required owner PublicKey User account that will own the new account. required Returns: Type Description PublicKey The pubkey of the new account. Source code in anchorpy/utils/token.py async def create_token_account ( prov : Provider , mint : PublicKey , owner : PublicKey , ) -> PublicKey : \"\"\"Create a token account. Args: prov: An anchorpy Provider instance. mint: The pubkey of the token's mint. owner: User account that will own the new account. Returns: The pubkey of the new account. \"\"\" token = AsyncToken ( prov . connection , mint , TOKEN_PROGRAM_ID , prov . wallet . payer ) return await token . create_account ( owner )","title":"create_token_account()"},{"location":"api_reference/#anchorpy.utils.token.create_token_account_instrs","text":"Generate instructions for creating a token account. Parameters: Name Type Description Default provider Provider An anchorpy Provider instance. required new_account_pubkey PublicKey The pubkey of the new account. required mint PublicKey The pubkey of the token's mint. required owner PublicKey User account that will own the new account. required Returns: Type Description tuple Transaction instructions to create the new account. Source code in anchorpy/utils/token.py async def create_token_account_instrs ( provider : Provider , new_account_pubkey : PublicKey , mint : PublicKey , owner : PublicKey , ) -> tuple [ TransactionInstruction , TransactionInstruction ]: \"\"\"Generate instructions for creating a token account. Args: provider: An anchorpy Provider instance. new_account_pubkey: The pubkey of the new account. mint: The pubkey of the token's mint. owner: User account that will own the new account. Returns: Transaction instructions to create the new account. \"\"\" mbre_resp = await provider . connection . get_minimum_balance_for_rent_exemption ( 165 ) lamports = mbre_resp [ \"result\" ] return ( create_account ( CreateAccountParams ( from_pubkey = provider . wallet . public_key , new_account_pubkey = new_account_pubkey , space = 165 , lamports = lamports , program_id = TOKEN_PROGRAM_ID , ) ), initialize_account ( InitializeAccountParams ( account = new_account_pubkey , mint = mint , owner = owner , program_id = TOKEN_PROGRAM_ID , ) ), )","title":"create_token_account_instrs()"},{"location":"api_reference/#anchorpy.utils.token.get_mint_info","text":"Retrieve mint information. Parameters: Name Type Description Default provider Provider The anchorpy Provider instance. required addr PublicKey The pubkey of the mint. required Returns: Type Description MintInfo The parsed MintInfo . Source code in anchorpy/utils/token.py async def get_mint_info ( provider : Provider , addr : PublicKey , ) -> MintInfo : \"\"\"Retrieve mint information. Args: provider: The anchorpy Provider instance. addr: The pubkey of the mint. Returns: The parsed `MintInfo`. \"\"\" depositor_acc_info_raw = await provider . connection . get_account_info ( addr ) return parse_mint_account ( depositor_acc_info_raw )","title":"get_mint_info()"},{"location":"api_reference/#anchorpy.utils.token.get_token_account","text":"Retrieve token account information. Parameters: Name Type Description Default provider Provider The anchorpy Provider instance. required addr PublicKey The pubkey of the token account. required Source code in anchorpy/utils/token.py async def get_token_account ( provider : Provider , addr : PublicKey ) -> AccountInfo : \"\"\"Retrieve token account information. Args: provider: The anchorpy Provider instance. addr: The pubkey of the token account. Returns: The parsed `AccountInfo` of the token account. \"\"\" depositor_acc_info_raw = await provider . connection . get_account_info ( addr ) return parse_token_account ( depositor_acc_info_raw )","title":"get_token_account()"},{"location":"api_reference/#anchorpy.utils.token.parse_mint_account","text":"Parse raw RPC response into MintInfo . Parameters: Name Type Description Default info RPCResponse The RPC response from calling .get_account_info for the mint pubkey. required Exceptions: Type Description AttributeError If the account is not owned by the Token Program. ValueError If the fetched data is the wrong size. Returns: Type Description MintInfo The parsed MintInfo . Source code in anchorpy/utils/token.py def parse_mint_account ( info : RPCResponse ) -> MintInfo : \"\"\"Parse raw RPC response into `MintInfo`. Args: info: The RPC response from calling `.get_account_info` for the mint pubkey. Raises: AttributeError: If the account is not owned by the Token Program. ValueError: If the fetched data is the wrong size. Returns: The parsed `MintInfo`. \"\"\" owner = info [ \"result\" ][ \"value\" ][ \"owner\" ] if owner != str ( TOKEN_PROGRAM_ID ): raise AttributeError ( f \"Invalid mint owner: { owner } \" ) bytes_data = decode_byte_string ( info [ \"result\" ][ \"value\" ][ \"data\" ][ 0 ]) if len ( bytes_data ) != MINT_LAYOUT . sizeof (): raise ValueError ( \"Invalid mint size\" ) decoded_data = MINT_LAYOUT . parse ( bytes_data ) decimals = decoded_data . decimals if decoded_data . mint_authority_option == 0 : mint_authority = None else : mint_authority = PublicKey ( decoded_data . mint_authority ) supply = decoded_data . supply is_initialized = decoded_data . is_initialized != 0 if decoded_data . freeze_authority_option == 0 : freeze_authority = None else : freeze_authority = PublicKey ( decoded_data . freeze_authority ) return MintInfo ( mint_authority , supply , decimals , is_initialized , freeze_authority )","title":"parse_mint_account()"},{"location":"api_reference/#anchorpy.utils.token.parse_token_account","text":"Parse AccountInfo from RPC response. Parameters: Name Type Description Default info RPCResponse the get_account_info RPC response. required Exceptions: Type Description ValueError If the fetched data is the wrong size. AttributeError If the account is not owned by the token program. Returns: Type Description AccountInfo The parsed AccountInfo . Source code in anchorpy/utils/token.py def parse_token_account ( info : RPCResponse ) -> AccountInfo : \"\"\"Parse `AccountInfo` from RPC response. Args: info: the `get_account_info` RPC response. Raises: ValueError: If the fetched data is the wrong size. AttributeError: If the account is not owned by the token program. Returns: The parsed `AccountInfo`. \"\"\" if not info : raise ValueError ( \"Invalid account owner\" ) if info [ \"result\" ][ \"value\" ][ \"owner\" ] != str ( TOKEN_PROGRAM_ID ): raise AttributeError ( \"Invalid account owner\" ) bytes_data = decode_byte_string ( info [ \"result\" ][ \"value\" ][ \"data\" ][ 0 ]) if len ( bytes_data ) != ACCOUNT_LAYOUT . sizeof (): raise ValueError ( \"Invalid account size\" ) decoded_data = ACCOUNT_LAYOUT . parse ( bytes_data ) mint = PublicKey ( decoded_data . mint ) owner = PublicKey ( decoded_data . owner ) amount = decoded_data . amount if decoded_data . delegate_option == 0 : delegate = None delegated_amount = 0 else : delegate = PublicKey ( decoded_data . delegate ) delegated_amount = decoded_data . delegated_amount is_initialized = decoded_data . state != 0 is_frozen = decoded_data . state == 2 if decoded_data . is_native_option == 1 : rent_exempt_reserve = decoded_data . is_native is_native = True else : rent_exempt_reserve = None is_native = False if decoded_data . close_authority_option == 0 : close_authority = None else : close_authority = PublicKey ( decoded_data . owner ) return AccountInfo ( mint , owner , amount , delegate , delegated_amount , is_initialized , is_frozen , is_native , rent_exempt_reserve , close_authority , )","title":"parse_token_account()"},{"location":"comparison_with_anchor_ts/","text":"Comparison with Typescript While AnchorPy is quite similar to the Anchor Typescript client, there are some differences: Dictionaries instead of objects AnchorPy tends to use dictionaries, so it uses [key] in some places where anchor-ts would use .key . For example, AnchorPy uses workspace[\"basic_1\"] instead of workspace.basic_1 , and program.rpc[\"initialize\"]() instead of program.rpc.initialize() Explicit Context object AnchorPy uses a Context dataclass and has a ctx keyword argument when calling .rpc functions, whereas Typescript is a bit less structured. We call program.rpc[\"my_func\"](ctx=Context({\"my_account\": my_account})) instead of program.rpc[\"my_func\"]({\"my_account\": my_account}) snake_case \ud83d\udc0d instead of camelCase \ud83d\udc2a AnchorPy uses more snake_case to match Rust and be Pythonic. Specifically, the following names are snake-case in AnchorPy: Workspaces: workspace[\"puppet_master\"] instead of workspace[\"puppetMaster\"] Instructions: program.rpc[\"my_func\"] (and program.instruction[\"my_func\"] ) instead of program.rpc[\"myFunc\"] . Accounts in the ctx arg: {\"my_account\": my_account} instead of {\"myAccount\": my_account} Fields in user-defined types: program.type[\"TransactionAccount\"](is_writable=True) instead of program.type[\"TransactionAccount\"](isWritable=True) program.type namespace for user-defined types The AnchorPy Program object has a .type attribute for instantiating user-defined types. This is not present in the Typescript client. See the examples for more on this.","title":"Comparison with Typescript"},{"location":"comparison_with_anchor_ts/#comparison-with-typescript","text":"While AnchorPy is quite similar to the Anchor Typescript client, there are some differences:","title":"Comparison with Typescript"},{"location":"comparison_with_anchor_ts/#dictionaries-instead-of-objects","text":"AnchorPy tends to use dictionaries, so it uses [key] in some places where anchor-ts would use .key . For example, AnchorPy uses workspace[\"basic_1\"] instead of workspace.basic_1 , and program.rpc[\"initialize\"]() instead of program.rpc.initialize()","title":"Dictionaries instead of objects"},{"location":"comparison_with_anchor_ts/#explicit-context-object","text":"AnchorPy uses a Context dataclass and has a ctx keyword argument when calling .rpc functions, whereas Typescript is a bit less structured. We call program.rpc[\"my_func\"](ctx=Context({\"my_account\": my_account})) instead of program.rpc[\"my_func\"]({\"my_account\": my_account})","title":"Explicit Context object"},{"location":"comparison_with_anchor_ts/#snake_case-instead-of-camelcase","text":"AnchorPy uses more snake_case to match Rust and be Pythonic. Specifically, the following names are snake-case in AnchorPy: Workspaces: workspace[\"puppet_master\"] instead of workspace[\"puppetMaster\"] Instructions: program.rpc[\"my_func\"] (and program.instruction[\"my_func\"] ) instead of program.rpc[\"myFunc\"] . Accounts in the ctx arg: {\"my_account\": my_account} instead of {\"myAccount\": my_account} Fields in user-defined types: program.type[\"TransactionAccount\"](is_writable=True) instead of program.type[\"TransactionAccount\"](isWritable=True)","title":"snake_case \ud83d\udc0d instead of camelCase \ud83d\udc2a"},{"location":"comparison_with_anchor_ts/#programtype-namespace-for-user-defined-types","text":"The AnchorPy Program object has a .type attribute for instantiating user-defined types. This is not present in the Typescript client. See the examples for more on this.","title":"program.type namespace for user-defined types"},{"location":"examples/","text":"Examples Here are some of the other things you can do with AnchorPy: Loading a Program from an on-chain IDL If a program's IDL is stored on-chain, you can use it to initialize a program object using Program.at . import asyncio from solana.rpc.async_api import AsyncClient from solana.publickey import PublicKey from anchorpy import Program , Provider , Wallet async def main (): client = AsyncClient ( \"https://api.mainnet-beta.solana.com/\" ) provider = Provider ( client , Wallet . local ()) # load the Serum Swap Program (not the Serum dex itself). program_id = PublicKey ( \"22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD\" ) program = await Program . at ( program_id , provider ) print ( program . idl . name ) # swap await program . close () asyncio . run ( main ()) Instantiating user-defined types with program.type Enums Suppose we have an instruction that expects an Enum called Side , with variants Buy and Sell . The Program object has a .type namespace to make it easy to use this enum: await program . rpc [ \"my_func\" ]( program . type [ \"Side\" ] . Buy ()) See test_token_proxy.py for a more concrete example. Structs .type also allows us to build structs defined in the IDL. See this snippet from test_multisig.py : program . type [ \"TransactionAccount\" ]( pubkey = multisig . public_key , is_writable = True , is_signer = False , ) Bulk-fetching data with .fetch_multiple You can use .fetch_multiple to get deserialized account data for many accounts at once. Look at this example from test_misc.py : n_accounts = 200 pubkeys = [ initialized_keypair . public_key ] * n_accounts # noqa: WPS435 data_accounts = await program . account [ \"Data\" ] . fetch_multiple ( pubkeys , batch_size = 2 ) The above example fetches data for the same pubkey 200 times which is not very interesting, but it could just as easily be fetching 200 different accounts. The .fetch_multiple method uses async batch RPC requests and getMultipleAccounts so it's quite efficient. Warning Be mindful of your RPC provider when fetching data, and plan out how many requests you'll end up sending to the RPC node. You can reliably fetch around 300 public keys in one HTTP request.","title":"Examples"},{"location":"examples/#examples","text":"Here are some of the other things you can do with AnchorPy:","title":"Examples"},{"location":"examples/#loading-a-program-from-an-on-chain-idl","text":"If a program's IDL is stored on-chain, you can use it to initialize a program object using Program.at . import asyncio from solana.rpc.async_api import AsyncClient from solana.publickey import PublicKey from anchorpy import Program , Provider , Wallet async def main (): client = AsyncClient ( \"https://api.mainnet-beta.solana.com/\" ) provider = Provider ( client , Wallet . local ()) # load the Serum Swap Program (not the Serum dex itself). program_id = PublicKey ( \"22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD\" ) program = await Program . at ( program_id , provider ) print ( program . idl . name ) # swap await program . close () asyncio . run ( main ())","title":"Loading a Program from an on-chain IDL"},{"location":"examples/#instantiating-user-defined-types-with-programtype","text":"","title":"Instantiating user-defined types with program.type"},{"location":"examples/#enums","text":"Suppose we have an instruction that expects an Enum called Side , with variants Buy and Sell . The Program object has a .type namespace to make it easy to use this enum: await program . rpc [ \"my_func\" ]( program . type [ \"Side\" ] . Buy ()) See test_token_proxy.py for a more concrete example.","title":"Enums"},{"location":"examples/#structs","text":".type also allows us to build structs defined in the IDL. See this snippet from test_multisig.py : program . type [ \"TransactionAccount\" ]( pubkey = multisig . public_key , is_writable = True , is_signer = False , )","title":"Structs"},{"location":"examples/#bulk-fetching-data-with-fetch_multiple","text":"You can use .fetch_multiple to get deserialized account data for many accounts at once. Look at this example from test_misc.py : n_accounts = 200 pubkeys = [ initialized_keypair . public_key ] * n_accounts # noqa: WPS435 data_accounts = await program . account [ \"Data\" ] . fetch_multiple ( pubkeys , batch_size = 2 ) The above example fetches data for the same pubkey 200 times which is not very interesting, but it could just as easily be fetching 200 different accounts. The .fetch_multiple method uses async batch RPC requests and getMultipleAccounts so it's quite efficient. Warning Be mindful of your RPC provider when fetching data, and plan out how many requests you'll end up sending to the RPC node. You can reliably fetch around 300 public keys in one HTTP request.","title":"Bulk-fetching data with .fetch_multiple"},{"location":"testing/","text":"Testing with AnchorPy Approaches There are two ways to test Anchor programs using AnchorPy: Using the AnchorPy Pytest plugin. Using anchor test and modifying Anchor.toml . 1. Pytest plugin AnchorPy provides a workspace_fixture function that creates a Pytest fixture. This fixture runs anchor localnet in the project root and shuts down the localnet when the tests are done. With this approach you're just running regular Pytest tests. This lets you do some things that you can't do with anchor test , like integrating closely with your IDE or opening a debugger when a test fails ( pytest --pdb ). Here's how it looks with the basic-1 tests: from pytest import fixture , mark from solana.keypair import Keypair from solana.system_program import SYS_PROGRAM_ID from anchorpy import Context , Program , workspace_fixture , WorkspaceType workspace = workspace_fixture ( \"anchor/examples/tutorial/basic-1\" ) # Since our other fixtures have module scope, we need to define # this event_loop fixture and give it module scope otherwise # pytest-asyncio will break. @fixture ( scope = \"module\" ) def event_loop (): \"\"\"Create an instance of the default event loop for each test case.\"\"\" loop = asyncio . get_event_loop_policy () . new_event_loop () yield loop loop . close () @fixture ( scope = \"module\" ) def program ( workspace : WorkspaceType ) -> Program : \"\"\"Create a Program instance.\"\"\" return workspace [ \"basic_1\" ] @fixture ( scope = \"module\" ) async def initialized_account ( program : Program ) -> Keypair : \"\"\"Generate a keypair and initialize it.\"\"\" my_account = Keypair () await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = { \"my_account\" : my_account . public_key , \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID , }, signers = [ my_account ], ), ) return my_account @mark . asyncio async def test_create_and_initialize_account ( program : Program , initialized_account : Keypair , ) -> None : \"\"\"Test creating and initializing account in single tx.\"\"\" account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . public_key ) assert account . data == 1234 @mark . asyncio async def test_update_previously_created_account ( initialized_account : Keypair , program : Program , ) -> None : \"\"\"Test updating a previously created account.\"\"\" await program . rpc [ \"update\" ]( 4321 , ctx = Context ( accounts = { \"my_account\" : initialized_account . public_key }), ) account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . public_key ) assert account . data == 4321 You can just run these tests with pytest (or have your IDE run them). Note There is also a lower-level localnet_fixture function that sets up a localnet for a particular project but doesn't return a workspace. 2. Anchor test Anchor lets you run whatever tests you want using the [scripts] section of Anchor.toml . This means we can call Pytest inside the anchor test workflow. This is more limited than the Pytest plugin but is more like the standard Anchor way of doing things. Here's how the basic-1 tests look using anchor test and Pytest (but not the ): # test_basic_1.py import asyncio from pathlib import Path from pytest import fixture , mark from anchorpy import create_workspace , close_workspace , Context , Program from solana.keypair import Keypair from solana.system_program import SYS_PROGRAM_ID # Since our other fixtures have module scope, we need to define # this event_loop fixture and give it module scope otherwise # pytest-asyncio will break. @fixture ( scope = \"module\" ) def event_loop (): \"\"\"Create an instance of the default event loop for each test case.\"\"\" loop = asyncio . get_event_loop_policy () . new_event_loop () yield loop loop . close () @fixture ( scope = \"module\" ) async def program () -> Program : workspace = create_workspace () yield workspace [ \"basic_1\" ] await close_workspace ( workspace ) @fixture ( scope = \"module\" ) async def initialized_account ( program : Program ) -> Keypair : my_account = Keypair () await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = { \"my_account\" : my_account . public_key , \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID , }, signers = [ my_account ], ), ) return my_account @mark . asyncio async def test_create_and_initialize_account ( program : Program , initialized_account : Keypair ) -> None : \"\"\"Test creating and initializing account in single tx.\"\"\" account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . public_key ) assert account . data == 1234 @mark . asyncio async def test_update_previously_created_account ( initialized_account : Keypair , program : Program ) -> None : \"\"\"Test updating a previously created account.\"\"\" await program . rpc [ \"update\" ]( 4321 , ctx = Context ( accounts = { \"myAccount\" : initialized_account . public_key }) ) account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . public_key ) assert account . data == 4321 Just paste this code into a file called test_basic_1.py in anchor/examples/tutorial/basic-1/tests/ , and change the scripts section of Anchor.toml to look like this: [scripts] test = \"pytest\" Then run anchor test and voila!. Note You must have pytest-asyncio installed for test_basic_1.py to work.","title":"Testing with AnchorPy"},{"location":"testing/#testing-with-anchorpy","text":"","title":"Testing with AnchorPy"},{"location":"testing/#approaches","text":"There are two ways to test Anchor programs using AnchorPy: Using the AnchorPy Pytest plugin. Using anchor test and modifying Anchor.toml .","title":"Approaches"},{"location":"testing/#1-pytest-plugin","text":"AnchorPy provides a workspace_fixture function that creates a Pytest fixture. This fixture runs anchor localnet in the project root and shuts down the localnet when the tests are done. With this approach you're just running regular Pytest tests. This lets you do some things that you can't do with anchor test , like integrating closely with your IDE or opening a debugger when a test fails ( pytest --pdb ). Here's how it looks with the basic-1 tests: from pytest import fixture , mark from solana.keypair import Keypair from solana.system_program import SYS_PROGRAM_ID from anchorpy import Context , Program , workspace_fixture , WorkspaceType workspace = workspace_fixture ( \"anchor/examples/tutorial/basic-1\" ) # Since our other fixtures have module scope, we need to define # this event_loop fixture and give it module scope otherwise # pytest-asyncio will break. @fixture ( scope = \"module\" ) def event_loop (): \"\"\"Create an instance of the default event loop for each test case.\"\"\" loop = asyncio . get_event_loop_policy () . new_event_loop () yield loop loop . close () @fixture ( scope = \"module\" ) def program ( workspace : WorkspaceType ) -> Program : \"\"\"Create a Program instance.\"\"\" return workspace [ \"basic_1\" ] @fixture ( scope = \"module\" ) async def initialized_account ( program : Program ) -> Keypair : \"\"\"Generate a keypair and initialize it.\"\"\" my_account = Keypair () await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = { \"my_account\" : my_account . public_key , \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID , }, signers = [ my_account ], ), ) return my_account @mark . asyncio async def test_create_and_initialize_account ( program : Program , initialized_account : Keypair , ) -> None : \"\"\"Test creating and initializing account in single tx.\"\"\" account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . public_key ) assert account . data == 1234 @mark . asyncio async def test_update_previously_created_account ( initialized_account : Keypair , program : Program , ) -> None : \"\"\"Test updating a previously created account.\"\"\" await program . rpc [ \"update\" ]( 4321 , ctx = Context ( accounts = { \"my_account\" : initialized_account . public_key }), ) account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . public_key ) assert account . data == 4321 You can just run these tests with pytest (or have your IDE run them). Note There is also a lower-level localnet_fixture function that sets up a localnet for a particular project but doesn't return a workspace.","title":"1. Pytest plugin"},{"location":"testing/#2-anchor-test","text":"Anchor lets you run whatever tests you want using the [scripts] section of Anchor.toml . This means we can call Pytest inside the anchor test workflow. This is more limited than the Pytest plugin but is more like the standard Anchor way of doing things. Here's how the basic-1 tests look using anchor test and Pytest (but not the ): # test_basic_1.py import asyncio from pathlib import Path from pytest import fixture , mark from anchorpy import create_workspace , close_workspace , Context , Program from solana.keypair import Keypair from solana.system_program import SYS_PROGRAM_ID # Since our other fixtures have module scope, we need to define # this event_loop fixture and give it module scope otherwise # pytest-asyncio will break. @fixture ( scope = \"module\" ) def event_loop (): \"\"\"Create an instance of the default event loop for each test case.\"\"\" loop = asyncio . get_event_loop_policy () . new_event_loop () yield loop loop . close () @fixture ( scope = \"module\" ) async def program () -> Program : workspace = create_workspace () yield workspace [ \"basic_1\" ] await close_workspace ( workspace ) @fixture ( scope = \"module\" ) async def initialized_account ( program : Program ) -> Keypair : my_account = Keypair () await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = { \"my_account\" : my_account . public_key , \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID , }, signers = [ my_account ], ), ) return my_account @mark . asyncio async def test_create_and_initialize_account ( program : Program , initialized_account : Keypair ) -> None : \"\"\"Test creating and initializing account in single tx.\"\"\" account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . public_key ) assert account . data == 1234 @mark . asyncio async def test_update_previously_created_account ( initialized_account : Keypair , program : Program ) -> None : \"\"\"Test updating a previously created account.\"\"\" await program . rpc [ \"update\" ]( 4321 , ctx = Context ( accounts = { \"myAccount\" : initialized_account . public_key }) ) account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . public_key ) assert account . data == 4321 Just paste this code into a file called test_basic_1.py in anchor/examples/tutorial/basic-1/tests/ , and change the scripts section of Anchor.toml to look like this: [scripts] test = \"pytest\" Then run anchor test and voila!. Note You must have pytest-asyncio installed for test_basic_1.py to work.","title":"2. Anchor test"},{"location":"tutorial/","text":"Tutorial This tutorial takes the JS snippets from the official Anchor tutorial and shows how to achieve the same thing using AnchorPy. Note The Python snippets are a bit longer because they contain all the code you need to run them. A Minimal Example This section covers the basic-0 tutorial: Generating a Client Here is how we generate a client from an IDL and use it to interact with a smart contract. Python JS from pathlib import Path import asyncio import json from solana.publickey import PublicKey from anchorpy import Idl , Program async def main (): # Read the generated IDL. with Path ( \"target/idl/basic_0.json\" ) . open () as f : raw_idl = json . load ( f ) idl = Idl . from_json ( raw_idl ) # Address of the deployed program. program_id = PublicKey ( \"<YOUR-PROGRAM-ID>\" ) # Generate the program client from IDL. program = Program ( idl , program_id ) # Execute the RPC. await program . rpc [ \"initialize\" ]() # Close the underlying http client, otherwise we get warnings. await program . close () asyncio . run ( main ()) // Read the generated IDL. const idl = JSON . parse ( require ( 'fs' ). readFileSync ( './target/idl/basic_0.json' , 'utf8' )); // Address of the deployed program. const programId = new anchor . web3 . PublicKey ( '<YOUR-PROGRAM-ID>' ); // Generate the program client from IDL. const program = new anchor . Program ( idl , programId ); // Execute the RPC. await program . rpc . initialize (); Note the differences between Python and JS here: We call program.rpc[\"initialize\"]() instead of program.rpc.initialize() We call program.close() to close the HTTP connection. Workspaces Here is how workspaces look in AnchorPy: Python JS import asyncio from anchorpy import create_workspace , close_workspace async def main (): # Read the deployed program from the workspace. workspace = create_workspace () program = workspace [ \"basic_0\" ] # Execute the RPC. await program . rpc [ \"initialize\" ]() # Close all HTTP clients in the workspace, otherwise we get warnings. await close_workspace ( workspace ) asyncio . run ( main ()) // Read the deployed program from the workspace. const program = anchor . workspace . Basic0 ; // Execute the RPC. await program . rpc . initialize (); Note the differences between Python and JS: Workspace instantiation is explicit: we have to call the create_workspace function. Note however that AnchorPy provides the workspace_fixture factory for convenience. See the testing section for more. We have a close_workspace function that calls close_program on all the programs in the workspace. The workspace is called basic_0 instead of Basic0 . This is because AnchorPy uses snake case \ud83d\udc0d Note AnchorPy uses the same case convention as Rust, so names should look just like they do in lib.rs . If you're unsure of a name, check program.idl : it shows how AnchorPy sees the IDL after parsing it and converting some cases. Arguments and Accounts Creating and Initializing Accounts Here is how we call an RPC function with arguments. As in the main Anchor tutorial, we will use anchor/tutorial/examples/basic-1 : Python JS import asyncio from solana.keypair import Keypair from solana.system_program import SYS_PROGRAM_ID from anchorpy import create_workspace , close_workspace , Context async def main (): # Read the deployed program from the workspace. workspace = create_workspace () # The program to execute. program = workspace [ \"basic_1\" ] # The Account to create. my_account = Keypair () # Execute the RPC. accounts = { \"my_account\" : my_account . public_key , \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID } await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = accounts , signers = [ my_account ])) # Close all HTTP clients in the workspace, otherwise we get warnings. await close_workspace ( workspace ) asyncio . run ( main ()) // The program to execute. const program = anchor . workspace . Basic1 ; // The Account to create. const myAccount = anchor . web3 . Keypair . generate (); // Create the new account and initialize it with the program. await program . rpc . initialize ( new anchor . BN ( 1234 ), { accounts : { myAccount : myAccount . publicKey , user : provider . wallet . publicKey , systemProgram : SystemProgram . programId , }, signers : [ myAccount ], }); Note how AnchorPy uses an explicit Context object in contrast to TS/JS.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This tutorial takes the JS snippets from the official Anchor tutorial and shows how to achieve the same thing using AnchorPy. Note The Python snippets are a bit longer because they contain all the code you need to run them.","title":"Tutorial"},{"location":"tutorial/#a-minimal-example","text":"This section covers the basic-0 tutorial:","title":"A Minimal Example"},{"location":"tutorial/#generating-a-client","text":"Here is how we generate a client from an IDL and use it to interact with a smart contract. Python JS from pathlib import Path import asyncio import json from solana.publickey import PublicKey from anchorpy import Idl , Program async def main (): # Read the generated IDL. with Path ( \"target/idl/basic_0.json\" ) . open () as f : raw_idl = json . load ( f ) idl = Idl . from_json ( raw_idl ) # Address of the deployed program. program_id = PublicKey ( \"<YOUR-PROGRAM-ID>\" ) # Generate the program client from IDL. program = Program ( idl , program_id ) # Execute the RPC. await program . rpc [ \"initialize\" ]() # Close the underlying http client, otherwise we get warnings. await program . close () asyncio . run ( main ()) // Read the generated IDL. const idl = JSON . parse ( require ( 'fs' ). readFileSync ( './target/idl/basic_0.json' , 'utf8' )); // Address of the deployed program. const programId = new anchor . web3 . PublicKey ( '<YOUR-PROGRAM-ID>' ); // Generate the program client from IDL. const program = new anchor . Program ( idl , programId ); // Execute the RPC. await program . rpc . initialize (); Note the differences between Python and JS here: We call program.rpc[\"initialize\"]() instead of program.rpc.initialize() We call program.close() to close the HTTP connection.","title":"Generating a Client"},{"location":"tutorial/#workspaces","text":"Here is how workspaces look in AnchorPy: Python JS import asyncio from anchorpy import create_workspace , close_workspace async def main (): # Read the deployed program from the workspace. workspace = create_workspace () program = workspace [ \"basic_0\" ] # Execute the RPC. await program . rpc [ \"initialize\" ]() # Close all HTTP clients in the workspace, otherwise we get warnings. await close_workspace ( workspace ) asyncio . run ( main ()) // Read the deployed program from the workspace. const program = anchor . workspace . Basic0 ; // Execute the RPC. await program . rpc . initialize (); Note the differences between Python and JS: Workspace instantiation is explicit: we have to call the create_workspace function. Note however that AnchorPy provides the workspace_fixture factory for convenience. See the testing section for more. We have a close_workspace function that calls close_program on all the programs in the workspace. The workspace is called basic_0 instead of Basic0 . This is because AnchorPy uses snake case \ud83d\udc0d Note AnchorPy uses the same case convention as Rust, so names should look just like they do in lib.rs . If you're unsure of a name, check program.idl : it shows how AnchorPy sees the IDL after parsing it and converting some cases.","title":"Workspaces"},{"location":"tutorial/#arguments-and-accounts","text":"","title":"Arguments and Accounts"},{"location":"tutorial/#creating-and-initializing-accounts","text":"Here is how we call an RPC function with arguments. As in the main Anchor tutorial, we will use anchor/tutorial/examples/basic-1 : Python JS import asyncio from solana.keypair import Keypair from solana.system_program import SYS_PROGRAM_ID from anchorpy import create_workspace , close_workspace , Context async def main (): # Read the deployed program from the workspace. workspace = create_workspace () # The program to execute. program = workspace [ \"basic_1\" ] # The Account to create. my_account = Keypair () # Execute the RPC. accounts = { \"my_account\" : my_account . public_key , \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID } await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = accounts , signers = [ my_account ])) # Close all HTTP clients in the workspace, otherwise we get warnings. await close_workspace ( workspace ) asyncio . run ( main ()) // The program to execute. const program = anchor . workspace . Basic1 ; // The Account to create. const myAccount = anchor . web3 . Keypair . generate (); // Create the new account and initialize it with the program. await program . rpc . initialize ( new anchor . BN ( 1234 ), { accounts : { myAccount : myAccount . publicKey , user : provider . wallet . publicKey , systemProgram : SystemProgram . programId , }, signers : [ myAccount ], }); Note how AnchorPy uses an explicit Context object in contrast to TS/JS.","title":"Creating and Initializing Accounts"}]}